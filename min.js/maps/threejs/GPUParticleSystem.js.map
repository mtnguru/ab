{"version":3,"sources":["threejs/GPUParticleSystem.js"],"names":["THREE","GPUParticleSystem","options","self","this","PARTICLE_COUNT","maxParticles","PARTICLE_CONTAINERS","containerCount","PARTICLES_PER_CONTAINER","Math","ceil","PARTICLE_CURSOR","time","GPUParticleShader","vertexShader","join","fragmentShader","rand","i","push","random","length","textureLoader","TextureLoader","particleNoiseTex","load","wrapS","wrapT","RepeatWrapping","particleSpriteTex","particleShaderMat","ShaderMaterial","transparent","depthWrite","uniforms","uTime","value","uScale","tNoise","tSprite","blending","AdditiveBlending","defaultAttributeValues","particlePositionsStartTime","particleVelColSizeLife","particleContainers","Object3D","apply","arguments","init","c","GPUParticleContainer","add","spawnParticle","floor","update","prototype","Object","create","constructor","particleSystem","decodeFloat","x","y","z","w","UINT8_VIEW","FLOAT_VIEW","hexToRgb","hex","r","g","b","DPR","window","devicePixelRatio","MAX_ATTRIBUTES","Uint8Array","Float32Array","buffer","particles","deadParticles","particlesAvailableSlot","particleUpdate","particleShaderGeo","BufferGeometry","particleVertices","addAttribute","BufferAttribute","setDynamic","posStart","getAttribute","velCol","Points","frustumCulled","position","Vector3","velocity","positionRandomness","velocityRandomness","color","colorRandomness","lifetime","size","sizeRandomness","offset","count","undefined","copy","set","turbulence","smoothPosition","array","velX","velY","velZ","rgb","geometryUpdate","updateRange","needsUpdate"],"mappings":"AAiBAA,MAAMC,kBAAoB,SAASC,GAElC,IAAIC,EAAOC,KACPF,EAAUA,MAGdC,EAAKE,eAAiBH,EAAQI,cAAgB,IAC9CH,EAAKI,oBAAsBL,EAAQM,gBAAkB,EACrDL,EAAKM,wBAA0BC,KAAKC,KAAKR,EAAKE,eAAiBF,EAAKI,qBACpEJ,EAAKS,gBAAkB,EACvBT,EAAKU,KAAO,EAIZ,IAAIC,GAEHC,cAEC,yBACA,sEACA,+CACA,2CAEA,mCACA,oCAEA,0CACA,2BAEA,yBACA,uBACA,mCACA,6BACA,+CACA,8BACA,+CACA,IAEA,gCAEA,kCACA,mCACA,2CAGA,2BACA,qBACA,6BACA,uBACA,+BAEA,oBACA,iCACA,6BACA,uBACA,gCAEA,oBACA,iCAEA,wBACA,oBACA,IAEA,kCACA,IACA,2EACA,qEACA,kEACA,8BACA,cACA,IAEA,yCACA,IACA,2FACA,4CACA,gBACA,IAEA,uBACA,wBACA,4BAEA,6CACA,yCAEA,uBACA,0BAEA,gBAEA,uCACA,qDAEA,uDACA,2DACA,uCACA,gCAEA,oBAEA,4DAEA,4DAEA,mEAEA,yCACA,yCACA,yCAEA,gHAEA,2HACA,4CAEA,kIAEA,8CACA,iBACA,IAEA,6BACA,iBACA,IAEA,2BACA,+EACA,WACA,4EACA,iBACA,qBACA,IACA,KAECC,KAAK,MAEPC,gBAEC,qDACA,oEACA,IAEA,sEACA,2EACA,IAEA,uBACA,0BAEA,6BAEA,gBAEA,oBAEA,0BACA,iHACA,WACA,0BACA,IAEA,kDAEA,4DACA,KAECD,KAAK,OAKRb,EAAKe,QAEL,IAAK,IAAIC,EAAI,IAAKA,EAAI,EAAGA,IACxBhB,EAAKe,KAAKE,KAAKV,KAAKW,SAAW,IAGhClB,EAAKkB,OAAS,WACb,QAASF,GAAKhB,EAAKe,KAAKI,OAASnB,EAAKe,KAAKC,EAAI,GAAKhB,EAAKe,KAAKC,IAG/D,IAAII,EAAgB,IAAIvB,MAAMwB,cAE9BrB,EAAKsB,iBAAmBF,EAAcG,KAAK,2BAC3CvB,EAAKsB,iBAAiBE,MAAQxB,EAAKsB,iBAAiBG,MAAQ5B,MAAM6B,eAElE1B,EAAK2B,kBAAoBP,EAAcG,KAAK,0BAC5CvB,EAAK2B,kBAAkBH,MAAQxB,EAAK2B,kBAAkBF,MAAQ5B,MAAM6B,eAEpE1B,EAAK4B,kBAAoB,IAAI/B,MAAMgC,gBAClCC,aAAa,EACbC,YAAY,EACZC,UACCC,OACCC,MAAO,GAERC,QACCD,MAAO,GAERE,QACCF,MAAOlC,EAAKsB,kBAEbe,SACCH,MAAOlC,EAAK2B,oBAGdW,SAAUzC,MAAM0C,iBAChB3B,aAAcD,EAAkBC,aAChCE,eAAgBH,EAAkBG,iBAInCd,EAAK4B,kBAAkBY,uBAAuBC,4BAA8B,EAAG,EAAG,EAAG,GACrFzC,EAAK4B,kBAAkBY,uBAAuBE,wBAA0B,EAAG,EAAG,EAAG,GAEjF1C,EAAK2C,sBAIL9C,MAAM+C,SAASC,MAAM5C,KAAM6C,WAE3B7C,KAAK8C,KAAO,WAEX,IAAK,IAAI/B,EAAI,EAAGA,EAAIhB,EAAKI,oBAAqBY,IAAK,CAElD,IAAIgC,EAAI,IAAInD,MAAMoD,qBAAqBjD,EAAKM,wBAAyBN,GACrEA,EAAK2C,mBAAmB1B,KAAK+B,GAC7BhD,EAAKkD,IAAIF,KAMX/C,KAAKkD,cAAgB,SAASpD,GAE7BC,EAAKS,kBACDT,EAAKS,iBAAmBT,EAAKE,iBAChCF,EAAKS,gBAAkB,GAGDT,EAAK2C,mBAAmBpC,KAAK6C,MAAMpD,EAAKS,gBAAkBT,EAAKM,0BAErE6C,cAAcpD,IAIhCE,KAAKoD,OAAS,SAAS3C,GACtB,IAAK,IAAIM,EAAI,EAAGA,EAAIhB,EAAKI,oBAAqBY,IAE7ChB,EAAK2C,mBAAmB3B,GAAGqC,OAAO3C,IAKpCT,KAAK8C,QAINlD,MAAMC,kBAAkBwD,UAAYC,OAAOC,OAAO3D,MAAM+C,SAASU,WACjEzD,MAAMC,kBAAkBwD,UAAUG,YAAc5D,MAAMC,kBAItDD,MAAMoD,qBAAuB,SAAS9C,EAAcuD,GAkBnD,SAASC,EAAYC,EAAGC,EAAGC,EAAGC,GAK7B,OAJAC,EAAW,GAAKzD,KAAK6C,MAAMW,GAC3BC,EAAW,GAAKzD,KAAK6C,MAAMU,GAC3BE,EAAW,GAAKzD,KAAK6C,MAAMS,GAC3BG,EAAW,GAAKzD,KAAK6C,MAAMQ,GACpBK,EAAW,GAYnB,SAASC,EAASC,GACjB,IAAIC,EAAID,GAAO,GACXE,GAAW,MAANF,IAAmB,EACxBG,EAAU,IAANH,EAMR,OAJIC,EAAI,GAAGA,IACPC,EAAI,GAAGA,IACPC,EAAI,GAAGA,KAEHF,EAAGC,EAAGC,GA1Cf,IAAItE,EAAOC,KACXD,EAAKE,eAAiBC,GAAgB,IACtCH,EAAKS,gBAAkB,EACvBT,EAAKU,KAAO,EACZV,EAAKuE,IAAMC,OAAOC,iBAClBzE,EAAKF,kBAAoB4D,EAEDnD,KAAK6C,MAAMpD,EAAKE,eAAiBF,EAAK0E,gBAG9D7E,MAAM+C,SAASC,MAAM5C,KAAM6C,WAG3B,IAAIkB,EAAa,IAAIW,WAAW,GAC5BV,EAAa,IAAIW,aAAaZ,EAAWa,QA+B7C7E,EAAK8E,aACL9E,EAAK+E,iBACL/E,EAAKgF,0BAGLhF,EAAKiF,gBAAiB,EAGtBjF,EAAKkF,kBAAoB,IAAIrF,MAAMsF,eAGnCnF,EAAKoF,iBAAmB,IAAIR,aAAmC,EAAtB5E,EAAKE,gBAC9CF,EAAKyC,2BAA6B,IAAImC,aAAmC,EAAtB5E,EAAKE,gBACxDF,EAAK0C,uBAAyB,IAAIkC,aAAmC,EAAtB5E,EAAKE,gBAEpD,IAASc,EAAI,EAAGA,EAAIhB,EAAKE,eAAgBc,IACxChB,EAAKyC,2BAA+B,EAAJzB,EAAQ,GAAK,IAC7ChB,EAAKyC,2BAA+B,EAAJzB,EAAQ,GAAK,EAC7ChB,EAAKyC,2BAA+B,EAAJzB,EAAQ,GAAK,EAC7ChB,EAAKyC,2BAA+B,EAAJzB,EAAQ,GAAK,EAE7ChB,EAAKoF,iBAAqB,EAAJpE,EAAQ,GAAK,EACnChB,EAAKoF,iBAAqB,EAAJpE,EAAQ,GAAK,EACnChB,EAAKoF,iBAAqB,EAAJpE,EAAQ,GAAK,EAEnChB,EAAK0C,uBAA2B,EAAJ1B,EAAQ,GAAK2C,EAAY,IAAK,IAAK,EAAG,GAClE3D,EAAK0C,uBAA2B,EAAJ1B,EAAQ,GAAK2C,EAAY,EAAG,IAAK,EAAG,KAChE3D,EAAK0C,uBAA2B,EAAJ1B,EAAQ,GAAK,EACzChB,EAAK0C,uBAA2B,EAAJ1B,EAAQ,GAAK,EAG1ChB,EAAKkF,kBAAkBG,aAAa,WAAY,IAAIxF,MAAMyF,gBAAgBtF,EAAKoF,iBAAkB,IACjGpF,EAAKkF,kBAAkBG,aAAa,6BAA8B,IAAIxF,MAAMyF,gBAAgBtF,EAAKyC,2BAA4B,GAAG8C,YAAW,IAC3IvF,EAAKkF,kBAAkBG,aAAa,yBAA0B,IAAIxF,MAAMyF,gBAAgBtF,EAAK0C,uBAAwB,GAAG6C,YAAW,IAEnIvF,EAAKwF,SAAWxF,EAAKkF,kBAAkBO,aAAa,8BACpDzF,EAAK0F,OAAS1F,EAAKkF,kBAAkBO,aAAa,0BAElDzF,EAAK4B,kBAAoB5B,EAAKF,kBAAkB8B,kBAEhD3B,KAAK8C,KAAO,WACX/C,EAAK0D,eAAiB,IAAI7D,MAAM8F,OAAO3F,EAAKkF,kBAAmBlF,EAAK4B,mBACpE5B,EAAK0D,eAAekC,eAAgB,EACpC3F,KAAKiD,IAAIlD,EAAK0D,iBAGf,IAWC1C,EAVA6E,EAAW,IAAIhG,MAAMiG,QACrBC,EAAW,IAAIlG,MAAMiG,QACrBE,EAAqB,EACrBC,EAAqB,EACrBC,EAAQ,SACRC,EAAkB,EAElBC,EAAW,EACXC,EAAO,EACPC,EAAiB,EAKlBrG,KAAKsG,OAAS,EACdtG,KAAKuG,MAAQ,EAEbvG,KAAKkD,cAAgB,SAASpD,GAK7B8F,OAAgCY,KAHhC1G,EAAUA,OAGS8F,SAAyBA,EAASa,KAAK3G,EAAQ8F,UAAYA,EAASc,IAAI,EAAI,EAAI,GACnGZ,OAAgCU,IAArB1G,EAAQgG,SAAyBA,EAASW,KAAK3G,EAAQgG,UAAYA,EAASY,IAAI,EAAI,EAAI,GACnGX,OAAoDS,IAA/B1G,EAAQiG,mBAAmCjG,EAAQiG,mBAAqB,EAC7FC,OAAoDQ,IAA/B1G,EAAQkG,mBAAmClG,EAAQkG,mBAAqB,EAC7FC,OAA0BO,IAAlB1G,EAAQmG,MAAsBnG,EAAQmG,MAAQ,SACtDC,OAA8CM,IAA5B1G,EAAQoG,gBAAgCpG,EAAQoG,gBAAkB,EACpFS,OAAoCH,IAAvB1G,EAAQ6G,WAA2B7G,EAAQ6G,WAAa,EACrER,OAAgCK,IAArB1G,EAAQqG,SAAyBrG,EAAQqG,SAAW,EAC/DC,OAAwBI,IAAjB1G,EAAQsG,KAAqBtG,EAAQsG,KAAO,GACnDC,OAA4CG,IAA3B1G,EAAQuG,eAA+BvG,EAAQuG,eAAiB,EAChFO,oBAA4CJ,IAA3B1G,EAAQ8G,gBAA+B9G,EAAQ8G,oBAEhDJ,IAAbzG,EAAKuE,MAAmB8B,GAAQrG,EAAKuE,KAEzCvD,EAAIhB,EAAKS,gBAETT,EAAKwF,SAASsB,MAAU,EAAJ9F,EAAQ,GAAK6E,EAASjC,EAAMF,EAAexC,SAAY8E,EAC3EhG,EAAKwF,SAASsB,MAAU,EAAJ9F,EAAQ,GAAK6E,EAAShC,EAAMH,EAAexC,SAAY8E,EAC3EhG,EAAKwF,SAASsB,MAAU,EAAJ9F,EAAQ,GAAK6E,EAAS/B,EAAMJ,EAAexC,SAAY8E,EAC3EhG,EAAKwF,SAASsB,MAAU,EAAJ9F,EAAQ,GAAKhB,EAAKU,KAAkC,IAA1BgD,EAAexC,UAEtC,IAAnB2F,iBACH7G,EAAKwF,SAASsB,MAAU,EAAJ9F,EAAQ,KAAQ+E,EAASnC,EAAIF,EAAexC,SAChElB,EAAKwF,SAASsB,MAAU,EAAJ9F,EAAQ,KAAQ+E,EAASlC,EAAIH,EAAexC,SAChElB,EAAKwF,SAASsB,MAAU,EAAJ9F,EAAQ,KAAQ+E,EAASjC,EAAIJ,EAAexC,UAGjE,IAAI6F,EAAOhB,EAASnC,EAAKF,EAAexC,SAAY+E,EAChDe,EAAOjB,EAASlC,EAAKH,EAAexC,SAAY+E,EAChDgB,EAAOlB,EAASjC,EAAKJ,EAAexC,SAAY+E,EAGhDW,EAAarG,KAAK6C,MAAmB,IAAbwD,GAG5BG,EAAOxG,KAAK6C,OAAoB2D,IA7CpB,GA6CsC,EA5CnC,KA6CfC,EAAOzG,KAAK6C,OAAoB4D,IA9CpB,GA8CsC,EA7CnC,KA8CfC,EAAO1G,KAAK6C,OAAoB6D,IA/CpB,GA+CsC,EA9CnC,KAgDfjH,EAAK0F,OAAOoB,MAAU,EAAJ9F,EAAQ,GAAK2C,EAAYoD,EAAMC,EAAMC,EAAML,GAI7D,IAAK,IAFDM,EAAMhD,EAASgC,GAEVlD,EAAI,EAAGA,EAAIkE,EAAI/F,OAAQ6B,IAC/BkE,EAAIlE,GAAKzC,KAAK6C,MAAM8D,EAAIlE,GAAOU,EAAexC,SAAYiF,EAAmB,KACzEe,EAAIlE,GAAK,MAAKkE,EAAIlE,GAAK,KACvBkE,EAAIlE,GAAK,IAAGkE,EAAIlE,GAAK,GAG1BhD,EAAK0F,OAAOoB,MAAU,EAAJ9F,EAAQ,GAAK2C,EAAYuD,EAAI,GAAIA,EAAI,GAAIA,EAAI,GAAI,KACnElH,EAAK0F,OAAOoB,MAAU,EAAJ9F,EAAQ,GAAKqF,EAAQ3C,EAAexC,SAAYoF,EAClEtG,EAAK0F,OAAOoB,MAAU,EAAJ9F,EAAQ,GAAKoF,EAEZ,GAAfnG,KAAKsG,SACRtG,KAAKsG,OAASvG,EAAKS,iBAGpBT,EAAKwG,QAELxG,EAAKS,kBAEDT,EAAKS,iBAAmBT,EAAKE,iBAChCF,EAAKS,gBAAkB,GAGxBT,EAAKiF,gBAAiB,GAIvBhF,KAAKoD,OAAS,SAAS3C,GAEtBV,EAAKU,KAAOA,EACZV,EAAK4B,kBAAkBI,SAAgB,MAAEE,MAAQxB,EAEjDT,KAAKkH,kBAINlH,KAAKkH,eAAiB,WACM,GAAvBnH,EAAKiF,iBACRjF,EAAKiF,gBAAiB,EAGlBjF,EAAKuG,OAASvG,EAAKwG,MAAQxG,EAAKE,gBACnCF,EAAKwF,SAAS4B,YAAYb,OAASvG,EAAK0F,OAAO0B,YAAYb,OAAuB,EAAdvG,EAAKuG,OACzEvG,EAAKwF,SAAS4B,YAAYZ,MAAQxG,EAAK0F,OAAO0B,YAAYZ,MAAqB,EAAbxG,EAAKwG,QAEvExG,EAAKwF,SAAS4B,YAAYb,OAAS,EACnCvG,EAAKwF,SAAS4B,YAAYZ,MAAQxG,EAAK0F,OAAO0B,YAAYZ,MAA+B,EAAtBxG,EAAKE,gBAGzEF,EAAKwF,SAAS6B,aAAc,EAC5BrH,EAAK0F,OAAO2B,aAAc,EAE1BrH,EAAKuG,OAAS,EACdvG,EAAKwG,MAAQ,IAIfvG,KAAK8C,QAINlD,MAAMoD,qBAAqBK,UAAYC,OAAOC,OAAO3D,MAAM+C,SAASU,WACpEzD,MAAMoD,qBAAqBK,UAAUG,YAAc5D,MAAMoD","file":"../../threejs/GPUParticleSystem.js","sourcesContent":["/*\n * GPU Particle System\n * @author flimshaw - Charlie Hoey - http://charliehoey.com\n *\n * A simple to use, general purpose GPU system. Particles are spawn-and-forget with\n * several options available, and do not require monitoring or cleanup after spawning.\n * Because the paths of all particles are completely deterministic once spawned, the scale\n * and direction of time is also variable.\n *\n * Currently uses a static wrapping perlin noise texture for turbulence, and a small png texture for\n * particles, but adding support for a particle texture atlas or changing to a different type of turbulence\n * would be a fairly light day's work.\n *\n * Shader and javascript packing code derrived from several Stack Overflow examples.\n *\n */\n\nTHREE.GPUParticleSystem = function(options) {\n\n\tvar self = this;\n\tvar options = options || {};\n\n\t// parse options and use defaults\n\tself.PARTICLE_COUNT = options.maxParticles || 1000000;\n\tself.PARTICLE_CONTAINERS = options.containerCount || 1;\n\tself.PARTICLES_PER_CONTAINER = Math.ceil(self.PARTICLE_COUNT / self.PARTICLE_CONTAINERS);\n\tself.PARTICLE_CURSOR = 0;\n\tself.time = 0;\n\n\n\t// Custom vertex and fragement shader\n\tvar GPUParticleShader = {\n\n\t\tvertexShader: [\n\n\t\t\t'precision highp float;',\n\t\t\t'const vec4 bitSh = vec4(256. * 256. * 256., 256. * 256., 256., 1.);',\n\t\t\t'const vec4 bitMsk = vec4(0.,vec3(1./256.0));',\n\t\t\t'const vec4 bitShifts = vec4(1.) / bitSh;',\n\n\t\t\t'#define FLOAT_MAX\t1.70141184e38',\n\t\t\t'#define FLOAT_MIN\t1.17549435e-38',\n\n\t\t\t'lowp vec4 encode_float(highp float v) {',\n\t\t\t'highp float av = abs(v);',\n\n\t\t\t'//Handle special cases',\n\t\t\t'if(av < FLOAT_MIN) {',\n\t\t\t'return vec4(0.0, 0.0, 0.0, 0.0);',\n\t\t\t'} else if(v > FLOAT_MAX) {',\n\t\t\t'return vec4(127.0, 128.0, 0.0, 0.0) / 255.0;',\n\t\t\t'} else if(v < -FLOAT_MAX) {',\n\t\t\t'return vec4(255.0, 128.0, 0.0, 0.0) / 255.0;',\n\t\t\t'}',\n\n\t\t\t'highp vec4 c = vec4(0,0,0,0);',\n\n\t\t\t'//Compute exponent and mantissa',\n\t\t\t'highp float e = floor(log2(av));',\n\t\t\t'highp float m = av * pow(2.0, -e) - 1.0;',\n\n\t\t\t//Unpack mantissa\n\t\t\t'c[1] = floor(128.0 * m);',\n\t\t\t'm -= c[1] / 128.0;',\n\t\t\t'c[2] = floor(32768.0 * m);',\n\t\t\t'm -= c[2] / 32768.0;',\n\t\t\t'c[3] = floor(8388608.0 * m);',\n\n\t\t\t'//Unpack exponent',\n\t\t\t'highp float ebias = e + 127.0;',\n\t\t\t'c[0] = floor(ebias / 2.0);',\n\t\t\t'ebias -= c[0] * 2.0;',\n\t\t\t'c[1] += floor(ebias) * 128.0;',\n\n\t\t\t'//Unpack sign bit',\n\t\t\t'c[0] += 128.0 * step(0.0, -v);',\n\n\t\t\t'//Scale back to range',\n\t\t\t'return c / 255.0;',\n\t\t\t'}',\n\n\t\t\t'vec4 pack(const in float depth)',\n\t\t\t'{',\n\t\t\t'const vec4 bit_shift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);',\n\t\t\t'const vec4 bit_mask\t= vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);',\n\t\t\t'vec4 res = mod(depth*bit_shift*vec4(255), vec4(256))/vec4(255);',\n\t\t\t'res -= res.xxyz * bit_mask;',\n\t\t\t'return res;',\n\t\t\t'}',\n\n\t\t\t'float unpack(const in vec4 rgba_depth)',\n\t\t\t'{',\n\t\t\t'const vec4 bit_shift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);',\n\t\t\t'float depth = dot(rgba_depth, bit_shift);',\n\t\t\t'return depth;',\n\t\t\t'}',\n\n\t\t\t'uniform float uTime;',\n\t\t\t'uniform float uScale;',\n\t\t\t'uniform sampler2D tNoise;',\n\n\t\t\t'attribute vec4 particlePositionsStartTime;',\n\t\t\t'attribute vec4 particleVelColSizeLife;',\n\n\t\t\t'varying vec4 vColor;',\n\t\t\t'varying float lifeLeft;',\n\n\t\t\t'void main() {',\n\n\t\t\t'// unpack things from our attributes',\n\t\t\t'vColor = encode_float( particleVelColSizeLife.y );',\n\n\t\t\t'// convert our velocity back into a value we can use',\n\t\t\t'vec4 velTurb = encode_float( particleVelColSizeLife.x );',\n\t\t\t'vec3 velocity = vec3( velTurb.xyz );',\n\t\t\t'float turbulence = velTurb.w;',\n\n\t\t\t'vec3 newPosition;',\n\n\t\t\t'float timeElapsed = uTime - particlePositionsStartTime.a;',\n\n\t\t\t'lifeLeft = 1. - (timeElapsed / particleVelColSizeLife.w);',\n\n\t\t\t'gl_PointSize = ( uScale * particleVelColSizeLife.z ) * lifeLeft;',\n\n\t\t\t'velocity.x = ( velocity.x - .5 ) * 3.;',\n\t\t\t'velocity.y = ( velocity.y - .5 ) * 3.;',\n\t\t\t'velocity.z = ( velocity.z - .5 ) * 3.;',\n\n\t\t\t'newPosition = particlePositionsStartTime.xyz + ( velocity * 10. ) * ( uTime - particlePositionsStartTime.a );',\n\n\t\t\t'vec3 noise = texture2D( tNoise, vec2( newPosition.x * .015 + (uTime * .05), newPosition.y * .02 + (uTime * .015) )).rgb;',\n\t\t\t'vec3 noiseVel = ( noise.rgb - .5 ) * 30.;',\n\n\t\t\t'newPosition = mix(newPosition, newPosition + vec3(noiseVel * ( turbulence * 5. ) ), (timeElapsed / particleVelColSizeLife.a) );',\n\n\t\t\t'if( velocity.y > 0. && velocity.y < .05 ) {',\n\t\t\t'lifeLeft = 0.;',\n\t\t\t'}',\n\n\t\t\t'if( velocity.x < -1.45 ) {',\n\t\t\t'lifeLeft = 0.;',\n\t\t\t'}',\n\n\t\t\t'if( timeElapsed > 0. ) {',\n\t\t\t'gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );',\n\t\t\t'} else {',\n\t\t\t'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\t\t\t'lifeLeft = 0.;',\n\t\t\t'gl_PointSize = 0.;',\n\t\t\t'}',\n\t\t\t'}'\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t'float scaleLinear(float value, vec2 valueDomain) {',\n\t\t\t'return (value - valueDomain.x) / (valueDomain.y - valueDomain.x);',\n\t\t\t'}',\n\n\t\t\t'float scaleLinear(float value, vec2 valueDomain, vec2 valueRange) {',\n\t\t\t'return mix(valueRange.x, valueRange.y, scaleLinear(value, valueDomain));',\n\t\t\t'}',\n\n\t\t\t'varying vec4 vColor;',\n\t\t\t'varying float lifeLeft;',\n\n\t\t\t'uniform sampler2D tSprite;',\n\n\t\t\t'void main() {',\n\n\t\t\t'float alpha = 0.;',\n\n\t\t\t'if( lifeLeft > .995 ) {',\n\t\t\t'alpha = scaleLinear( lifeLeft, vec2(1., .995), vec2(0., 1.));//mix( 0., 1., ( lifeLeft - .95 ) * 100. ) * .75;',\n\t\t\t'} else {',\n\t\t\t'alpha = lifeLeft * .75;',\n\t\t\t'}',\n\n\t\t\t'vec4 tex = texture2D( tSprite, gl_PointCoord );',\n\n\t\t\t'gl_FragColor = vec4( vColor.rgb * tex.a, alpha * tex.a );',\n\t\t\t'}'\n\n\t\t].join(\"\\n\")\n\n\t};\n\n\t// preload a million random numbers\n\tself.rand = [];\n\n\tfor (var i = 1e5; i > 0; i--) {\n\t\tself.rand.push(Math.random() - .5);\n\t}\n\n\tself.random = function() {\n\t\treturn ++i >= self.rand.length ? self.rand[i = 1] : self.rand[i];\n\t}\n\n\tvar textureLoader = new THREE.TextureLoader();\n\n\tself.particleNoiseTex = textureLoader.load(\"textures/perlin-512.png\");\n\tself.particleNoiseTex.wrapS = self.particleNoiseTex.wrapT = THREE.RepeatWrapping;\n\n\tself.particleSpriteTex = textureLoader.load(\"textures/particle2.png\");\n\tself.particleSpriteTex.wrapS = self.particleSpriteTex.wrapT = THREE.RepeatWrapping;\n\n\tself.particleShaderMat = new THREE.ShaderMaterial({\n\t\ttransparent: true,\n\t\tdepthWrite: false,\n\t\tuniforms: {\n\t\t\t\"uTime\": {\n\t\t\t\tvalue: 0.0\n\t\t\t},\n\t\t\t\"uScale\": {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\t\t\t\"tNoise\": {\n\t\t\t\tvalue: self.particleNoiseTex\n\t\t\t},\n\t\t\t\"tSprite\": {\n\t\t\t\tvalue: self.particleSpriteTex\n\t\t\t}\n\t\t},\n\t\tblending: THREE.AdditiveBlending,\n\t\tvertexShader: GPUParticleShader.vertexShader,\n\t\tfragmentShader: GPUParticleShader.fragmentShader\n\t});\n\n\t// define defaults for all values\n\tself.particleShaderMat.defaultAttributeValues.particlePositionsStartTime = [0, 0, 0, 0];\n\tself.particleShaderMat.defaultAttributeValues.particleVelColSizeLife = [0, 0, 0, 0];\n\n\tself.particleContainers = [];\n\n\n\t// extend Object3D\n\tTHREE.Object3D.apply(this, arguments);\n\n\tthis.init = function() {\n\n\t\tfor (var i = 0; i < self.PARTICLE_CONTAINERS; i++) {\n\n\t\t\tvar c = new THREE.GPUParticleContainer(self.PARTICLES_PER_CONTAINER, self);\n\t\t\tself.particleContainers.push(c);\n\t\t\tself.add(c);\n\n\t\t}\n\n\t}\n\n\tthis.spawnParticle = function(options) {\n\n\t\tself.PARTICLE_CURSOR++;\n\t\tif (self.PARTICLE_CURSOR >= self.PARTICLE_COUNT) {\n\t\t\tself.PARTICLE_CURSOR = 1;\n\t\t}\n\n\t\tvar currentContainer = self.particleContainers[Math.floor(self.PARTICLE_CURSOR / self.PARTICLES_PER_CONTAINER)];\n\n\t\tcurrentContainer.spawnParticle(options);\n\n\t}\n\n\tthis.update = function(time) {\n\t\tfor (var i = 0; i < self.PARTICLE_CONTAINERS; i++) {\n\n\t\t\tself.particleContainers[i].update(time);\n\n\t\t}\n\t};\n\n\tthis.init();\n\n}\n\nTHREE.GPUParticleSystem.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.GPUParticleSystem.prototype.constructor = THREE.GPUParticleSystem;\n\n\n// Subclass for particle containers, allows for very large arrays to be spread out\nTHREE.GPUParticleContainer = function(maxParticles, particleSystem) {\n\n\tvar self = this;\n\tself.PARTICLE_COUNT = maxParticles || 100000;\n\tself.PARTICLE_CURSOR = 0;\n\tself.time = 0;\n\tself.DPR = window.devicePixelRatio;\n\tself.GPUParticleSystem = particleSystem;\n\n\tvar particlesPerArray = Math.floor(self.PARTICLE_COUNT / self.MAX_ATTRIBUTES);\n\n\t// extend Object3D\n\tTHREE.Object3D.apply(this, arguments);\n\n\t// construct a couple small arrays used for packing variables into floats etc\n\tvar UINT8_VIEW = new Uint8Array(4)\n\tvar FLOAT_VIEW = new Float32Array(UINT8_VIEW.buffer)\n\n\tfunction decodeFloat(x, y, z, w) {\n\t\tUINT8_VIEW[0] = Math.floor(w)\n\t\tUINT8_VIEW[1] = Math.floor(z)\n\t\tUINT8_VIEW[2] = Math.floor(y)\n\t\tUINT8_VIEW[3] = Math.floor(x)\n\t\treturn FLOAT_VIEW[0]\n\t}\n\n\tfunction componentToHex(c) {\n\t\tvar hex = c.toString(16);\n\t\treturn hex.length == 1 ? \"0\" + hex : hex;\n\t}\n\n\tfunction rgbToHex(r, g, b) {\n\t\treturn \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n\t}\n\n\tfunction hexToRgb(hex) {\n\t\tvar r = hex >> 16;\n\t\tvar g = (hex & 0x00FF00) >> 8;\n\t\tvar b = hex & 0x0000FF;\n\n\t\tif (r > 0) r--;\n\t\tif (g > 0) g--;\n\t\tif (b > 0) b--;\n\n\t\treturn [r, g, b];\n\t};\n\n\tself.particles = [];\n\tself.deadParticles = [];\n\tself.particlesAvailableSlot = [];\n\n\t// create a container for particles\n\tself.particleUpdate = false;\n\n\t// Shader Based Particle System\n\tself.particleShaderGeo = new THREE.BufferGeometry();\n\n\t// new hyper compressed attributes\n\tself.particleVertices = new Float32Array(self.PARTICLE_COUNT * 3); // position\n\tself.particlePositionsStartTime = new Float32Array(self.PARTICLE_COUNT * 4); // position\n\tself.particleVelColSizeLife = new Float32Array(self.PARTICLE_COUNT * 4);\n\n\tfor (var i = 0; i < self.PARTICLE_COUNT; i++) {\n\t\tself.particlePositionsStartTime[i * 4 + 0] = 100; //x\n\t\tself.particlePositionsStartTime[i * 4 + 1] = 0; //y\n\t\tself.particlePositionsStartTime[i * 4 + 2] = 0.0; //z\n\t\tself.particlePositionsStartTime[i * 4 + 3] = 0.0; //startTime\n\n\t\tself.particleVertices[i * 3 + 0] = 0; //x\n\t\tself.particleVertices[i * 3 + 1] = 0; //y\n\t\tself.particleVertices[i * 3 + 2] = 0.0; //z\n\n\t\tself.particleVelColSizeLife[i * 4 + 0] = decodeFloat(128, 128, 0, 0); //vel\n\t\tself.particleVelColSizeLife[i * 4 + 1] = decodeFloat(0, 254, 0, 254); //color\n\t\tself.particleVelColSizeLife[i * 4 + 2] = 1.0; //size\n\t\tself.particleVelColSizeLife[i * 4 + 3] = 0.0; //lifespan\n\t}\n\n\tself.particleShaderGeo.addAttribute('position', new THREE.BufferAttribute(self.particleVertices, 3));\n\tself.particleShaderGeo.addAttribute('particlePositionsStartTime', new THREE.BufferAttribute(self.particlePositionsStartTime, 4).setDynamic(true));\n\tself.particleShaderGeo.addAttribute('particleVelColSizeLife', new THREE.BufferAttribute(self.particleVelColSizeLife, 4).setDynamic(true));\n\n\tself.posStart = self.particleShaderGeo.getAttribute('particlePositionsStartTime')\n\tself.velCol = self.particleShaderGeo.getAttribute('particleVelColSizeLife');\n\n\tself.particleShaderMat = self.GPUParticleSystem.particleShaderMat;\n\n\tthis.init = function() {\n\t\tself.particleSystem = new THREE.Points(self.particleShaderGeo, self.particleShaderMat);\n\t\tself.particleSystem.frustumCulled = false;\n\t\tthis.add(self.particleSystem);\n\t};\n\n\tvar options = {},\n\t\tposition = new THREE.Vector3(),\n\t\tvelocity = new THREE.Vector3(),\n\t\tpositionRandomness = 0.,\n\t\tvelocityRandomness = 0.,\n\t\tcolor = 0xffffff,\n\t\tcolorRandomness = 0.,\n\t\tturbulence = 0.,\n\t\tlifetime = 0.,\n\t\tsize = 0.,\n\t\tsizeRandomness = 0.,\n\t\ti;\n\n\tvar maxVel = 2;\n\tvar maxSource = 250;\n\tthis.offset = 0;\n\tthis.count = 0;\n\n\tthis.spawnParticle = function(options) {\n\n\t\toptions = options || {};\n\n\t\t// setup reasonable default values for all arguments\n\t\tposition = options.position !== undefined ? position.copy(options.position) : position.set(0., 0., 0.);\n\t\tvelocity = options.velocity !== undefined ? velocity.copy(options.velocity) : velocity.set(0., 0., 0.);\n\t\tpositionRandomness = options.positionRandomness !== undefined ? options.positionRandomness : 0.0;\n\t\tvelocityRandomness = options.velocityRandomness !== undefined ? options.velocityRandomness : 0.0;\n\t\tcolor = options.color !== undefined ? options.color : 0xffffff;\n\t\tcolorRandomness = options.colorRandomness !== undefined ? options.colorRandomness : 1.0;\n\t\tturbulence = options.turbulence !== undefined ? options.turbulence : 1.0;\n\t\tlifetime = options.lifetime !== undefined ? options.lifetime : 5.0;\n\t\tsize = options.size !== undefined ? options.size : 10;\n\t\tsizeRandomness = options.sizeRandomness !== undefined ? options.sizeRandomness : 0.0,\n\t\t\tsmoothPosition = options.smoothPosition !== undefined ? options.smoothPosition : false;\n\n\t\tif (self.DPR !== undefined) size *= self.DPR;\n\n\t\ti = self.PARTICLE_CURSOR;\n\n\t\tself.posStart.array[i * 4 + 0] = position.x + ((particleSystem.random()) * positionRandomness); // - ( velocity.x * particleSystem.random() ); //x\n\t\tself.posStart.array[i * 4 + 1] = position.y + ((particleSystem.random()) * positionRandomness); // - ( velocity.y * particleSystem.random() ); //y\n\t\tself.posStart.array[i * 4 + 2] = position.z + ((particleSystem.random()) * positionRandomness); // - ( velocity.z * particleSystem.random() ); //z\n\t\tself.posStart.array[i * 4 + 3] = self.time + (particleSystem.random() * 2e-2); //startTime\n\n\t\tif (smoothPosition === true) {\n\t\t\tself.posStart.array[i * 4 + 0] += -(velocity.x * particleSystem.random()); //x\n\t\t\tself.posStart.array[i * 4 + 1] += -(velocity.y * particleSystem.random()); //y\n\t\t\tself.posStart.array[i * 4 + 2] += -(velocity.z * particleSystem.random()); //z\n\t\t}\n\n\t\tvar velX = velocity.x + (particleSystem.random()) * velocityRandomness;\n\t\tvar velY = velocity.y + (particleSystem.random()) * velocityRandomness;\n\t\tvar velZ = velocity.z + (particleSystem.random()) * velocityRandomness;\n\n\t\t// convert turbulence rating to something we can pack into a vec4\n\t\tvar turbulence = Math.floor(turbulence * 254);\n\n\t\t// clamp our value to between 0. and 1.\n\t\tvelX = Math.floor(maxSource * ((velX - -maxVel) / (maxVel - -maxVel)));\n\t\tvelY = Math.floor(maxSource * ((velY - -maxVel) / (maxVel - -maxVel)));\n\t\tvelZ = Math.floor(maxSource * ((velZ - -maxVel) / (maxVel - -maxVel)));\n\n\t\tself.velCol.array[i * 4 + 0] = decodeFloat(velX, velY, velZ, turbulence); //vel\n\n\t\tvar rgb = hexToRgb(color);\n\n\t\tfor (var c = 0; c < rgb.length; c++) {\n\t\t\trgb[c] = Math.floor(rgb[c] + ((particleSystem.random()) * colorRandomness) * 254);\n\t\t\tif (rgb[c] > 254) rgb[c] = 254;\n\t\t\tif (rgb[c] < 0) rgb[c] = 0;\n\t\t}\n\n\t\tself.velCol.array[i * 4 + 1] = decodeFloat(rgb[0], rgb[1], rgb[2], 254); //color\n\t\tself.velCol.array[i * 4 + 2] = size + (particleSystem.random()) * sizeRandomness; //size\n\t\tself.velCol.array[i * 4 + 3] = lifetime; //lifespan\n\n\t\tif (this.offset == 0) {\n\t\t\tthis.offset = self.PARTICLE_CURSOR;\n\t\t}\n\n\t\tself.count++;\n\n\t\tself.PARTICLE_CURSOR++;\n\n\t\tif (self.PARTICLE_CURSOR >= self.PARTICLE_COUNT) {\n\t\t\tself.PARTICLE_CURSOR = 0;\n\t\t}\n\n\t\tself.particleUpdate = true;\n\n\t}\n\n\tthis.update = function(time) {\n\n\t\tself.time = time;\n\t\tself.particleShaderMat.uniforms['uTime'].value = time;\n\n\t\tthis.geometryUpdate();\n\n\t};\n\n\tthis.geometryUpdate = function() {\n\t\tif (self.particleUpdate == true) {\n\t\t\tself.particleUpdate = false;\n\n\t\t\t// if we can get away with a partial buffer update, do so\n\t\t\tif (self.offset + self.count < self.PARTICLE_COUNT) {\n\t\t\t\tself.posStart.updateRange.offset = self.velCol.updateRange.offset = self.offset * 4;\n\t\t\t\tself.posStart.updateRange.count = self.velCol.updateRange.count = self.count * 4;\n\t\t\t} else {\n\t\t\t\tself.posStart.updateRange.offset = 0;\n\t\t\t\tself.posStart.updateRange.count = self.velCol.updateRange.count = (self.PARTICLE_COUNT * 4);\n\t\t\t}\n\n\t\t\tself.posStart.needsUpdate = true;\n\t\t\tself.velCol.needsUpdate = true;\n\n\t\t\tself.offset = 0;\n\t\t\tself.count = 0;\n\t\t}\n\t}\n\n\tthis.init();\n\n}\n\nTHREE.GPUParticleContainer.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.GPUParticleContainer.prototype.constructor = THREE.GPUParticleContainer;\n"]}