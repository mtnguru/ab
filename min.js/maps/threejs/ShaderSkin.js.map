{"version":3,"sources":["threejs/ShaderSkin.js"],"names":["THREE","ShaderSkin","skinSimple","uniforms","UniformsUtils","merge","UniformsLib","enableBump","value","enableSpecular","tDiffuse","tBeckmann","diffuse","Color","specular","opacity","uRoughness","uSpecularBrightness","bumpMap","bumpScale","specularMap","offsetRepeat","Vector4","uWrapRGB","Vector3","fragmentShader","ShaderChunk","join","vertexShader","skin","passID","tNormal","tBlur1","tBlur2","tBlur3","tBlur4","uNormalScale","vertexShaderUV","beckmann"],"mappings":"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","file":"../../threejs/ShaderSkin.js","sourcesContent":["/**\n * @author alteredq / http://alteredqualia.com/\n *\n */\n\n\nTHREE.ShaderSkin = {\n\n\t/* ------------------------------------------------------------------------------------------\n\t//\tSimple skin shader\n\t//\t\t- per-pixel Blinn-Phong diffuse term mixed with half-Lambert wrap-around term (per color component)\n\t//\t\t- physically based specular term (Kelemen/Szirmay-Kalos specular reflectance)\n\t//\n\t//\t\t- diffuse map\n\t//\t\t- bump map\n\t//\t\t- specular map\n\t//\t\t- point, directional and hemisphere lights (use with \"lights: true\" material option)\n\t//\t\t- fog (use with \"fog: true\" material option)\n\t//\t\t- shadow maps\n\t//\n\t// ------------------------------------------------------------------------------------------ */\n\n\t'skinSimple' : {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\n\t\t\t{\n\n\t\t\t\t\"enableBump\": { value: 0 },\n\t\t\t\t\"enableSpecular\": { value: 0 },\n\n\t\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\t\"tBeckmann\": { value: null },\n\n\t\t\t\t\"diffuse\": { value: new THREE.Color( 0xeeeeee ) },\n\t\t\t\t\"specular\": { value: new THREE.Color( 0x111111 ) },\n\t\t\t\t\"opacity\": { value: 1 },\n\n\t\t\t\t\"uRoughness\": { value: 0.15 },\n\t\t\t\t\"uSpecularBrightness\": { value: 0.75 },\n\n\t\t\t\t\"bumpMap\": { value: null },\n\t\t\t\t\"bumpScale\": { value: 1 },\n\n\t\t\t\t\"specularMap\": { value: null },\n\n\t\t\t\t\"offsetRepeat\": { value: new THREE.Vector4( 0, 0, 1, 1 ) },\n\n\t\t\t\t\"uWrapRGB\": { value: new THREE.Vector3( 0.75, 0.375, 0.1875 ) }\n\n\t\t\t}\n\n\t\t] ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"#define USE_BUMPMAP\",\n\n\t\t\t\"uniform bool enableBump;\",\n\t\t\t\"uniform bool enableSpecular;\",\n\n\t\t\t\"uniform vec3 diffuse;\",\n\t\t\t\"uniform vec3 specular;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"uniform float uRoughness;\",\n\t\t\t\"uniform float uSpecularBrightness;\",\n\n\t\t\t\"uniform vec3 uWrapRGB;\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform sampler2D tBeckmann;\",\n\n\t\t\t\"uniform sampler2D specularMap;\",\n\n\t\t\t\"varying vec3 vNormal;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"varying vec3 vViewPosition;\",\n\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\n\t\t\tTHREE.ShaderChunk[ \"bsdfs\" ],\n\t\t\tTHREE.ShaderChunk[ \"packing\" ],\n\t\t\tTHREE.ShaderChunk[ \"lights_pars\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"bumpmap_pars_fragment\" ],\n\n\t\t\t// Fresnel term\n\n\t\t\t\"float fresnelReflectance( vec3 H, vec3 V, float F0 ) {\",\n\n\t\t\t\t\"float base = 1.0 - dot( V, H );\",\n\t\t\t\t\"float exponential = pow( base, 5.0 );\",\n\n\t\t\t\t\"return exponential + F0 * ( 1.0 - exponential );\",\n\n\t\t\t\"}\",\n\n\t\t\t// Kelemen/Szirmay-Kalos specular BRDF\n\n\t\t\t\"float KS_Skin_Specular( vec3 N,\", \t\t// Bumped surface normal\n\t\t\t\t\t\t\t\t\t\"vec3 L,\", \t\t// Points to light\n\t\t\t\t\t\t\t\t\t\"vec3 V,\", \t\t// Points to eye\n\t\t\t\t\t\t\t\t\t\"float m,\",  \t// Roughness\n\t\t\t\t\t\t\t\t\t\"float rho_s\", \t// Specular brightness\n\t\t\t\t\t\t\t\t\t\") {\",\n\n\t\t\t\t\"float result = 0.0;\",\n\t\t\t\t\"float ndotl = dot( N, L );\",\n\n\t\t\t\t\"if( ndotl > 0.0 ) {\",\n\n\t\t\t\t\t\"vec3 h = L + V;\", // Unnormalized half-way vector\n\t\t\t\t\t\"vec3 H = normalize( h );\",\n\n\t\t\t\t\t\"float ndoth = dot( N, H );\",\n\n\t\t\t\t\t\"float PH = pow( 2.0 * texture2D( tBeckmann, vec2( ndoth, m ) ).x, 10.0 );\",\n\n\t\t\t\t\t\"float F = fresnelReflectance( H, V, 0.028 );\",\n\t\t\t\t\t\"float frSpec = max( PH * F / dot( h, h ), 0.0 );\",\n\n\t\t\t\t\t\"result = ndotl * rho_s * frSpec;\", // BRDF * dot(N,L) * rho_s\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"return result;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\n\t\t\t\t\"vec4 diffuseColor = vec4( diffuse, opacity );\",\n\n\t\t\t\t\"vec4 colDiffuse = texture2D( tDiffuse, vUv );\",\n\t\t\t\t\"colDiffuse.rgb *= colDiffuse.rgb;\",\n\n\t\t\t\t\"diffuseColor = diffuseColor * colDiffuse;\",\n\n\t\t\t\t\"vec3 normal = normalize( vNormal );\",\n\t\t\t\t\"vec3 viewerDirection = normalize( vViewPosition );\",\n\n\t\t\t\t\"float specularStrength;\",\n\n\t\t\t\t\"if ( enableSpecular ) {\",\n\n\t\t\t\t\t\"vec4 texelSpecular = texture2D( specularMap, vUv );\",\n\t\t\t\t\t\"specularStrength = texelSpecular.r;\",\n\n\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\"specularStrength = 1.0;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"#ifdef USE_BUMPMAP\",\n\n\t\t\t\t\t\"if ( enableBump ) normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// point lights\n\n\t\t\t\t\"vec3 totalSpecularLight = vec3( 0.0 );\",\n\t\t\t\t\"vec3 totalDiffuseLight = vec3( 0.0 );\",\n\n\t\t\t\t\"#if NUM_POINT_LIGHTS > 0\",\n\n\t\t\t\t\t\"for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\t\t\"vec3 lVector = pointLights[ i ].position + vViewPosition.xyz;\",\n\n\t\t\t\t\t\t\"float attenuation = calcLightAttenuation( length( lVector ), pointLights[ i ].distance, pointLights[ i ].decay );\",\n\n\t\t\t\t\t\t\"lVector = normalize( lVector );\",\n\n\t\t\t\t\t\t\"float pointDiffuseWeightFull = max( dot( normal, lVector ), 0.0 );\",\n\t\t\t\t\t\t\"float pointDiffuseWeightHalf = max( 0.5 * dot( normal, lVector ) + 0.5, 0.0 );\",\n\t\t\t\t\t\t\"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), uWrapRGB );\",\n\n\t\t\t\t\t\t\"float pointSpecularWeight = KS_Skin_Specular( normal, lVector, viewerDirection, uRoughness, uSpecularBrightness );\",\n\n\t\t\t\t\t\t\"totalDiffuseLight += pointLight[ i ].color * ( pointDiffuseWeight * attenuation );\",\n\t\t\t\t\t\t\"totalSpecularLight += pointLight[ i ].color * specular * ( pointSpecularWeight * specularStrength * attenuation );\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// directional lights\n\n\t\t\t\t\"#if NUM_DIR_LIGHTS > 0\",\n\n\t\t\t\t\t\"for( int i = 0; i < NUM_DIR_LIGHTS; i++ ) {\",\n\n\t\t\t\t\t\t\"vec3 dirVector = directionalLights[ i ].direction;\",\n\n\t\t\t\t\t\t\"float dirDiffuseWeightFull = max( dot( normal, dirVector ), 0.0 );\",\n\t\t\t\t\t\t\"float dirDiffuseWeightHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\",\n\t\t\t\t\t\t\"vec3 dirDiffuseWeight = mix( vec3 ( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), uWrapRGB );\",\n\n\t\t\t\t\t\t\"float dirSpecularWeight = KS_Skin_Specular( normal, dirVector, viewerDirection, uRoughness, uSpecularBrightness );\",\n\n\t\t\t\t\t\t\"totalDiffuseLight += directionalLights[ i ].color * dirDiffuseWeight;\",\n\t\t\t\t\t\t\"totalSpecularLight += directionalLights[ i ].color * ( dirSpecularWeight * specularStrength );\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// hemisphere lights\n\n\t\t\t\t\"#if NUM_HEMI_LIGHTS > 0\",\n\n\t\t\t\t\t\"for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\t\t\"vec3 lVector = hemisphereLightDirection[ i ];\",\n\n\t\t\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\t\t\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\n\n\t\t\t\t\t\t\"totalDiffuseLight += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\n\n\t\t\t\t\t\t// specular (sky light)\n\n\t\t\t\t\t\t\"float hemiSpecularWeight = 0.0;\",\n\t\t\t\t\t\t\"hemiSpecularWeight += KS_Skin_Specular( normal, lVector, viewerDirection, uRoughness, uSpecularBrightness );\",\n\n\t\t\t\t\t\t// specular (ground light)\n\n\t\t\t\t\t\t\"vec3 lVectorGround = -lVector;\",\n\t\t\t\t\t\t\"hemiSpecularWeight += KS_Skin_Specular( normal, lVectorGround, viewerDirection, uRoughness, uSpecularBrightness );\",\n\n\t\t\t\t\t\t\"vec3 hemiSpecularColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\n\n\t\t\t\t\t\t\"totalSpecularLight += hemiSpecularColor * specular * ( hemiSpecularWeight * specularStrength );\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"outgoingLight += diffuseColor.xyz * ( totalDiffuseLight + ambientLightColor * diffuse ) + totalSpecularLight;\",\n\n\t\t\t\t\"gl_FragColor = linearToOutputTexel( vec4( outgoingLight, diffuseColor.a ) );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\n\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform vec4 offsetRepeat;\",\n\n\t\t\t\"varying vec3 vNormal;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"varying vec3 vViewPosition;\",\n\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\n\t\t\tTHREE.ShaderChunk[ \"lights_pars\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\n\n\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\n\n\t\t\t\t\"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\",\n\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t},\n\n\t/* ------------------------------------------------------------------------------------------\n\t//\tSkin shader\n\t//\t\t- Blinn-Phong diffuse term (using normal + diffuse maps)\n\t//\t\t- subsurface scattering approximation by four blur layers\n\t//\t\t- physically based specular term (Kelemen/Szirmay-Kalos specular reflectance)\n\t//\n\t//\t\t- point and directional lights (use with \"lights: true\" material option)\n\t//\n\t//\t\t- based on Nvidia Advanced Skin Rendering GDC 2007 presentation\n\t//\t\t  and GPU Gems 3 Chapter 14. Advanced Techniques for Realistic Real-Time Skin Rendering\n\t//\n\t//\t\t\thttp://developer.download.nvidia.com/presentations/2007/gdc/Advanced_Skin.pdf\n\t//\t\t\thttp://http.developer.nvidia.com/GPUGems3/gpugems3_ch14.html\n\t// ------------------------------------------------------------------------------------------ */\n\n\t'skin' : {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\n\t\t\t{\n\n\t\t\t\t\"passID\": { value: 0 },\n\n\t\t\t\t\"tDiffuse\"\t: { value: null },\n\t\t\t\t\"tNormal\"\t: { value: null },\n\n\t\t\t\t\"tBlur1\"\t: { value: null },\n\t\t\t\t\"tBlur2\"\t: { value: null },\n\t\t\t\t\"tBlur3\"\t: { value: null },\n\t\t\t\t\"tBlur4\"\t: { value: null },\n\n\t\t\t\t\"tBeckmann\"\t: { value: null },\n\n\t\t\t\t\"uNormalScale\": { value: 1.0 },\n\n\t\t\t\t\"diffuse\":  { value: new THREE.Color( 0xeeeeee ) },\n\t\t\t\t\"specular\": { value: new THREE.Color( 0x111111 ) },\n\t\t\t\t\"opacity\": \t  { value: 1 },\n\n\t\t\t\t\"uRoughness\": \t  \t\t{ value: 0.15 },\n\t\t\t\t\"uSpecularBrightness\": \t{ value: 0.75 }\n\n\t\t\t}\n\n\t\t] ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 diffuse;\",\n\t\t\t\"uniform vec3 specular;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"uniform float uRoughness;\",\n\t\t\t\"uniform float uSpecularBrightness;\",\n\n\t\t\t\"uniform int passID;\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform sampler2D tNormal;\",\n\n\t\t\t\"uniform sampler2D tBlur1;\",\n\t\t\t\"uniform sampler2D tBlur2;\",\n\t\t\t\"uniform sampler2D tBlur3;\",\n\t\t\t\"uniform sampler2D tBlur4;\",\n\n\t\t\t\"uniform sampler2D tBeckmann;\",\n\n\t\t\t\"uniform float uNormalScale;\",\n\n\t\t\t\"varying vec3 vNormal;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"varying vec3 vViewPosition;\",\n\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\n\t\t\tTHREE.ShaderChunk[ \"lights_pars\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\n\t\t\t\"float fresnelReflectance( vec3 H, vec3 V, float F0 ) {\",\n\n\t\t\t\t\"float base = 1.0 - dot( V, H );\",\n\t\t\t\t\"float exponential = pow( base, 5.0 );\",\n\n\t\t\t\t\"return exponential + F0 * ( 1.0 - exponential );\",\n\n\t\t\t\"}\",\n\n\t\t\t// Kelemen/Szirmay-Kalos specular BRDF\n\n\t\t\t\"float KS_Skin_Specular( vec3 N,\", \t\t// Bumped surface normal\n\t\t\t\t\t\t\t\t\t\"vec3 L,\", \t\t// Points to light\n\t\t\t\t\t\t\t\t\t\"vec3 V,\", \t\t// Points to eye\n\t\t\t\t\t\t\t\t\t\"float m,\",  \t// Roughness\n\t\t\t\t\t\t\t\t\t\"float rho_s\", \t// Specular brightness\n\t\t\t\t\t\t\t\t\t\") {\",\n\n\t\t\t\t\"float result = 0.0;\",\n\t\t\t\t\"float ndotl = dot( N, L );\",\n\n\t\t\t\t\"if( ndotl > 0.0 ) {\",\n\n\t\t\t\t\t\"vec3 h = L + V;\", // Unnormalized half-way vector\n\t\t\t\t\t\"vec3 H = normalize( h );\",\n\n\t\t\t\t\t\"float ndoth = dot( N, H );\",\n\n\t\t\t\t\t\"float PH = pow( 2.0 * texture2D( tBeckmann, vec2( ndoth, m ) ).x, 10.0 );\",\n\t\t\t\t\t\"float F = fresnelReflectance( H, V, 0.028 );\",\n\t\t\t\t\t\"float frSpec = max( PH * F / dot( h, h ), 0.0 );\",\n\n\t\t\t\t\t\"result = ndotl * rho_s * frSpec;\", // BRDF * dot(N,L) * rho_s\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"return result;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\n\t\t\t\t\"vec4 diffuseColor = vec4( diffuse, opacity );\",\n\n\t\t\t\t\"vec4 mSpecular = vec4( specular, opacity );\",\n\n\t\t\t\t\"vec4 colDiffuse = texture2D( tDiffuse, vUv );\",\n\t\t\t\t\"colDiffuse *= colDiffuse;\",\n\n\t\t\t\t\"diffuseColor *= colDiffuse;\",\n\n\t\t\t\t// normal mapping\n\n\t\t\t\t\"vec4 posAndU = vec4( -vViewPosition, vUv.x );\",\n\t\t\t\t\"vec4 posAndU_dx = dFdx( posAndU ),  posAndU_dy = dFdy( posAndU );\",\n\t\t\t\t\"vec3 tangent = posAndU_dx.w * posAndU_dx.xyz + posAndU_dy.w * posAndU_dy.xyz;\",\n\t\t\t\t\"vec3 normal = normalize( vNormal );\",\n\t\t\t\t\"vec3 binormal = normalize( cross( tangent, normal ) );\",\n\t\t\t\t\"tangent = cross( normal, binormal );\",\t// no normalization required\n\t\t\t\t\"mat3 tsb = mat3( tangent, binormal, normal );\",\n\n\t\t\t\t\"vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\",\n\t\t\t\t\"normalTex.xy *= uNormalScale;\",\n\t\t\t\t\"normalTex = normalize( normalTex );\",\n\n\t\t\t\t\"vec3 finalNormal = tsb * normalTex;\",\n\t\t\t\t\"normal = normalize( finalNormal );\",\n\n\t\t\t\t\"vec3 viewerDirection = normalize( vViewPosition );\",\n\n\t\t\t\t// point lights\n\n\t\t\t\t\"vec3 totalDiffuseLight = vec3( 0.0 );\",\n\t\t\t\t\"vec3 totalSpecularLight = vec3( 0.0 );\",\n\n\t\t\t\t\"#if NUM_POINT_LIGHTS > 0\",\n\n\t\t\t\t\t\"for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\t\t\"vec3 pointVector = normalize( pointLights[ i ].direction );\",\n\t\t\t\t\t\t\"float attenuation = calcLightAttenuation( length( lVector ), pointLights[ i ].distance, pointLights[ i ].decay );\",\n\n\t\t\t\t\t\t\"float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\",\n\n\t\t\t\t\t\t\"totalDiffuseLight += pointLightColor[ i ] * ( pointDiffuseWeight * attenuation );\",\n\n\t\t\t\t\t\t\"if ( passID == 1 ) {\",\n\n\t\t\t\t\t\t\t\"float pointSpecularWeight = KS_Skin_Specular( normal, pointVector, viewerDirection, uRoughness, uSpecularBrightness );\",\n\n\t\t\t\t\t\t\t\"totalSpecularLight += pointLightColor[ i ] * mSpecular.xyz * ( pointSpecularWeight * attenuation );\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// directional lights\n\n\t\t\t\t\"#if NUM_DIR_LIGHTS > 0\",\n\n\t\t\t\t\t\"for( int i = 0; i < NUM_DIR_LIGHTS; i++ ) {\",\n\n\t\t\t\t\t\t\"vec3 dirVector = directionalLights[ i ].direction;\",\n\n\t\t\t\t\t\t\"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\",\n\n\n\t\t\t\t\t\t\"totalDiffuseLight += directionalLights[ i ].color * dirDiffuseWeight;\",\n\n\t\t\t\t\t\t\"if ( passID == 1 ) {\",\n\n\t\t\t\t\t\t\t\"float dirSpecularWeight = KS_Skin_Specular( normal, dirVector, viewerDirection, uRoughness, uSpecularBrightness );\",\n\n\t\t\t\t\t\t\t\"totalSpecularLight += directionalLights[ i ].color * mSpecular.xyz * dirSpecularWeight;\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\n\t\t\t\t\"outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalSpecularLight );\",\n\n\t\t\t\t\"if ( passID == 0 ) {\",\n\n\t\t\t\t\t\"outgoingLight = sqrt( outgoingLight );\",\n\n\t\t\t\t\"} else if ( passID == 1 ) {\",\n\n\t\t\t\t\t//\"#define VERSION1\",\n\n\t\t\t\t\t\"#ifdef VERSION1\",\n\n\t\t\t\t\t\t\"vec3 nonblurColor = sqrt(outgoingLight );\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"vec3 nonblurColor = outgoingLight;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"vec3 blur1Color = texture2D( tBlur1, vUv ).xyz;\",\n\t\t\t\t\t\"vec3 blur2Color = texture2D( tBlur2, vUv ).xyz;\",\n\t\t\t\t\t\"vec3 blur3Color = texture2D( tBlur3, vUv ).xyz;\",\n\t\t\t\t\t\"vec3 blur4Color = texture2D( tBlur4, vUv ).xyz;\",\n\n\n\t\t\t\t\t//\"gl_FragColor = vec4( blur1Color, gl_FragColor.w );\",\n\n\t\t\t\t\t//\"gl_FragColor = vec4( vec3( 0.22, 0.5, 0.7 ) * nonblurColor + vec3( 0.2, 0.5, 0.3 ) * blur1Color + vec3( 0.58, 0.0, 0.0 ) * blur2Color, gl_FragColor.w );\",\n\n\t\t\t\t\t//\"gl_FragColor = vec4( vec3( 0.25, 0.6, 0.8 ) * nonblurColor + vec3( 0.15, 0.25, 0.2 ) * blur1Color + vec3( 0.15, 0.15, 0.0 ) * blur2Color + vec3( 0.45, 0.0, 0.0 ) * blur3Color, gl_FragColor.w );\",\n\n\n\t\t\t\t\t\"outgoingLight = vec3( vec3( 0.22,  0.437, 0.635 ) * nonblurColor + \",\n\t\t\t\t\t\t\t\t\t\t \"vec3( 0.101, 0.355, 0.365 ) * blur1Color + \",\n\t\t\t\t\t\t\t\t\t\t \"vec3( 0.119, 0.208, 0.0 )   * blur2Color + \",\n\t\t\t\t\t\t\t\t\t\t \"vec3( 0.114, 0.0,   0.0 )   * blur3Color + \",\n\t\t\t\t\t\t\t\t\t\t \"vec3( 0.444, 0.0,   0.0 )   * blur4Color );\",\n\n\t\t\t\t\t\"outgoingLight *= sqrt( colDiffuse.xyz );\",\n\n\t\t\t\t\t\"outgoingLight += ambientLightColor * diffuse * colDiffuse.xyz + totalSpecularLight;\",\n\n\t\t\t\t\t\"#ifndef VERSION1\",\n\n\t\t\t\t\t\t\"outgoingLight = sqrt( outgoingLight );\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"gl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\n\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tvertexShader: [\n\n\t\t\t\"#ifdef VERTEX_TEXTURES\",\n\n\t\t\t\t\"uniform sampler2D tDisplacement;\",\n\t\t\t\t\"uniform float uDisplacementScale;\",\n\t\t\t\t\"uniform float uDisplacementBias;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"varying vec3 vNormal;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"varying vec3 vViewPosition;\",\n\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\n\n\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\n\n\t\t\t\t\"vUv = uv;\",\n\n\t\t\t\t// displacement mapping\n\n\t\t\t\t\"#ifdef VERTEX_TEXTURES\",\n\n\t\t\t\t\t\"vec3 dv = texture2D( tDisplacement, uv ).xyz;\",\n\t\t\t\t\t\"float df = uDisplacementScale * dv.x + uDisplacementBias;\",\n\t\t\t\t\t\"vec4 displacedPosition = vec4( vNormal.xyz * df, 0.0 ) + mvPosition;\",\n\t\t\t\t\t\"gl_Position = projectionMatrix * displacedPosition;\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tvertexShaderUV: [\n\n\t\t\t\"varying vec3 vNormal;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"varying vec3 vViewPosition;\",\n\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\n\n\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\n\n\t\t\t\t\"vUv = uv;\",\n\n\t\t\t\t\"gl_Position = vec4( uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, 0.0, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t},\n\n\t/* ------------------------------------------------------------------------------------------\n\t// Beckmann distribution function\n\t//\t- to be used in specular term of skin shader\n\t//\t- render a screen-aligned quad to precompute a 512 x 512 texture\n\t//\n\t//\t\t- from http://developer.nvidia.com/node/171\n\t ------------------------------------------------------------------------------------------ */\n\n\t\"beckmann\" : {\n\n\t\tuniforms: {},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vUv = uv;\",\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"float PHBeckmann( float ndoth, float m ) {\",\n\n\t\t\t\t\"float alpha = acos( ndoth );\",\n\t\t\t\t\"float ta = tan( alpha );\",\n\n\t\t\t\t\"float val = 1.0 / ( m * m * pow( ndoth, 4.0 ) ) * exp( -( ta * ta ) / ( m * m ) );\",\n\t\t\t\t\"return val;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"float KSTextureCompute( vec2 tex ) {\",\n\n\t\t\t\t// Scale the value to fit within [0,1]  invert upon lookup.\n\n\t\t\t\t\"return 0.5 * pow( PHBeckmann( tex.x, tex.y ), 0.1 );\",\n\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"float x = KSTextureCompute( vUv );\",\n\n\t\t\t\t\"gl_FragColor = vec4( x, x, x, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t}\n\n};\n"]}