{"version":3,"sources":["threejs/TimelinerController.js"],"names":["THREE","TimelinerController","scene","trackInfo","onUpdate","this","_scene","_trackInfo","_onUpdate","_mixer","AnimationMixer","_clip","_action","_tracks","_propRefs","_channelNames","prototype","constructor","init","timeliner","tracks","i","n","length","spec","push","_addTrack","type","propertyPath","initialValue","interpolation","AnimationClip","clipAction","play","setDisplayTime","time","update","setDuration","duration","getChannelNames","getChannelKeyTimes","channelName","times","setKeyframe","track","index","Timeliner","binarySearch","values","stride","getValueSize","offset","nTimes","nValues","e","getValue","delKeyframe","pop","moveKeyframe","delta","moveRemaining","endAt","needsSort","_sort","serialize","result","channels","names","name","deserialize","structs","data","_setArray","order","AnimationUtils","getKeyframeOrder","sortedArray","dst","src","apply","prop","Array","slice","call","PropertyBinding"],"mappings":"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","file":"../../threejs/TimelinerController.js","sourcesContent":["/**\n * Controller class for the Timeliner GUI.\n *\n * Timeliner GUI library (required to use this class):\n *\n * \t\t./libs/timeliner_gui.min.js\n *\n * Source code:\n *\n * \t\thttps://github.com/tschw/timeliner_gui\n * \t\thttps://github.com/zz85/timeliner (fork's origin)\n *\n * @author tschw\n *\n */\n\nTHREE.TimelinerController = function TimelinerController( scene, trackInfo, onUpdate ) {\n\n\tthis._scene = scene;\n\tthis._trackInfo = trackInfo;\n\n\tthis._onUpdate = onUpdate;\n\n\tthis._mixer = new THREE.AnimationMixer( scene );\n\tthis._clip = null;\n\tthis._action = null;\n\n\tthis._tracks = {};\n\tthis._propRefs = {};\n\tthis._channelNames = [];\n\n};\n\nTHREE.TimelinerController.prototype = {\n\n\tconstructor: THREE.TimelinerController,\n\n\tinit: function( timeliner ) {\n\n\t\tvar tracks = [],\n\t\t\ttrackInfo = this._trackInfo;\n\n\t\tfor ( var i = 0, n = trackInfo.length; i !== n; ++ i ) {\n\n\t\t\tvar spec = trackInfo[ i ];\n\n\t\t\ttracks.push( this._addTrack(\n\t\t\t\t\tspec.type, spec.propertyPath,\n\t\t\t\t\tspec.initialValue, spec.interpolation ) );\n\t\t}\n\n\t\tthis._clip = new THREE.AnimationClip( 'editclip', 0, tracks );\n\t\tthis._action = this._mixer.clipAction( this._clip ).play();\n\n\t},\n\n\tsetDisplayTime: function( time ) {\n\n\t\tthis._action.time = time;\n\t\tthis._mixer.update( 0 );\n\n\t\tthis._onUpdate();\n\n\t},\n\n\tsetDuration: function( duration ) {\n\n\t\tthis._clip.duration = duration;\n\n\t},\n\n\tgetChannelNames: function() {\n\n\t\treturn this._channelNames;\n\n\t},\n\n\tgetChannelKeyTimes: function( channelName ) {\n\n\t\treturn this._tracks[ channelName ].times;\n\n\t},\n\n\tsetKeyframe: function( channelName, time ) {\n\n\t\tvar track = this._tracks[ channelName ],\n\t\t\ttimes = track.times,\n\t\t\tindex = Timeliner.binarySearch( times, time ),\n\t\t\tvalues = track.values,\n\t\t\tstride = track.getValueSize(),\n\t\t\toffset = index * stride;\n\n\t\tif ( index < 0 ) {\n\n\t\t\t// insert new keyframe\n\n\t\t\tindex = ~ index;\n\t\t\toffset = index * stride;\n\n\t\t\tvar nTimes = times.length + 1,\n\t\t\t\tnValues = values.length + stride;\n\n\t\t\tfor ( var i = nTimes - 1; i !== index; -- i ) {\n\n\t\t\t\ttimes[ i ] = times[ i - 1 ];\n\n\t\t\t}\n\n\t\t\tfor ( var i = nValues - 1,\n\t\t\t\t\te = offset + stride - 1; i !== e; -- i ) {\n\n\t\t\t\tvalues[ i ] = values[ i - stride ];\n\n\t\t\t}\n\n\t\t}\n\n\t\ttimes[ index ] = time;\n\t\tthis._propRefs[ channelName ].getValue( values, offset );\n\n\t},\n\n\tdelKeyframe: function( channelName, time ) {\n\n\t\tvar track = this._tracks[ channelName ],\n\t\t\ttimes = track.times,\n\t\t\tindex = Timeliner.binarySearch( times, time );\n\n\t\t// we disallow to remove the keyframe when it is the last one we have,\n\t\t// since the animation system is designed to always produce a defined\n\t\t// state\n\n\t\tif ( times.length > 1 && index >= 0 ) {\n\n\t\t\tvar nTimes = times.length - 1,\n\t\t\t\tvalues = track.values,\n\t\t\t\tstride = track.getValueSize(),\n\t\t\t\tnValues = values.length - stride;\n\n\t\t\t// note: no track.getValueSize when array sizes are out of sync\n\n\t\t\tfor ( var i = index; i !== nTimes; ++ i ) {\n\n\t\t\t\ttimes[ i ] = times[ i + 1 ];\n\n\t\t\t}\n\n\t\t\ttimes.pop();\n\n\t\t\tfor ( var offset = index * stride; offset !== nValues; ++ offset ) {\n\n\t\t\t\tvalues[ offset ] = values[ offset + stride ];\n\n\t\t\t}\n\n\t\t\tvalues.length = nValues;\n\n\t\t}\n\n\t},\n\n\tmoveKeyframe: function( channelName, time, delta, moveRemaining ) {\n\n\t\tvar track = this._tracks[ channelName ],\n\t\t\ttimes = track.times,\n\t\t\tindex = Timeliner.binarySearch( times, time );\n\n\t\tif ( index >= 0 ) {\n\n\t\t\tvar endAt = moveRemaining ? times.length : index + 1,\n\t\t\t\tneedsSort = times[ index - 1 ] <= time ||\n\t\t\t\t\t! moveRemaining && time >= times[ index + 1 ];\n\n\t\t\twhile ( index !== endAt ) times[ index ++ ] += delta;\n\n\t\t\tif ( needsSort ) this._sort( track );\n\n\t\t}\n\n\t},\n\n\tserialize: function() {\n\n\t\tvar result = {\n\t\t\t\tduration: this._clip.duration,\n\t\t\t\tchannels: {}\n\t\t\t},\n\n\t\t\tnames = this._channelNames,\n\t\t\ttracks = this._tracks,\n\n\t\t\tchannels = result.channels;\n\n\t\tfor ( var i = 0, n = names.length; i !== n; ++ i ) {\n\n\t\t\tvar name = names[ i ],\n\t\t\t\ttrack = tracks[ name ];\n\n\t\t\tchannels[ name ] = {\n\n\t\t\t\ttimes: track.times,\n\t\t\t\tvalues: track.values\n\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\tdeserialize: function( structs ) {\n\n\t\tvar names = this._channelNames,\n\t\t\ttracks = this._tracks,\n\n\t\t\tchannels = structs.channels;\n\n\t\tthis.setDuration( structs.duration );\n\n\t\tfor ( var i = 0, n = names.length; i !== n; ++ i ) {\n\n\t\t\tvar name = names[ i ],\n\t\t\t\ttrack = tracks[ name ];\n\t\t\t\tdata = channels[ name ];\n\n\t\t\tthis._setArray( track.times, data.times );\n\t\t\tthis._setArray( track.values, data.values );\n\n\t\t}\n\n\t\t// update display\n\t\tthis.setDisplayTime( this._mixer.time );\n\n\t},\n\n\t_sort: function( track ) {\n\n\t\tvar times = track.times,\n\t\t\torder = THREE.AnimationUtils.getKeyframeOrder( times );\n\n\t\tthis._setArray( times,\n\t\t\t\tTHREE.AnimationUtils.sortedArray( times, 1, order ) );\n\n\t\tvar values = track.values,\n\t\t\tstride = track.getValueSize();\n\n\t\tthis._setArray( values,\n\t\t\t\tTHREE.AnimationUtils.sortedArray( values, stride, order ) );\n\n\t},\n\n\t_setArray: function( dst, src ) {\n\n\t\tdst.length = 0;\n\t\tdst.push.apply( dst, src );\n\n\t},\n\n\t_addTrack: function( type, prop, initialValue, interpolation ) {\n\n\t\tvar track = new type(\n\t\t\t\tprop, [ 0 ], initialValue, interpolation );\n\n\t\t// data must be in JS arrays so it can be resized\n\t\ttrack.times = Array.prototype.slice.call( track.times );\n\t\ttrack.values = Array.prototype.slice.call( track.values );\n\n\t\tthis._channelNames.push( prop );\n\t\tthis._tracks[ prop ] = track;\n\n\t\t// for recording the state:\n\t\tthis._propRefs[ prop ] =\n\t\t\t\tnew THREE.PropertyBinding( this._scene, prop );\n\n\t\treturn track;\n\n\t}\n\n};\n"]}