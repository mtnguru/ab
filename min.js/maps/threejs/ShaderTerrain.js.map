{"version":3,"sources":["threejs/ShaderTerrain.js"],"names":["THREE","ShaderTerrain","terrain","uniforms","UniformsUtils","merge","UniformsLib","enableDiffuse1","value","enableDiffuse2","enableSpecular","enableReflection","tDiffuse1","tDiffuse2","tDetail","tNormal","tSpecular","tDisplacement","uNormalScale","uDisplacementBias","uDisplacementScale","diffuse","Color","specular","shininess","opacity","uRepeatBase","Vector2","uRepeatOverlay","uOffset","fragmentShader","ShaderChunk","join","vertexShader"],"mappings":"AAKAA,MAAMC,eAULC,SAECC,SAAUH,MAAMI,cAAcC,OAE7BL,MAAMM,YAAmB,IACzBN,MAAMM,YAAsB,QAI3BC,gBAAoBC,MAAO,GAC3BC,gBAAoBD,MAAO,GAC3BE,gBAAoBF,MAAO,GAC3BG,kBAAsBH,MAAO,GAE7BI,WAAeJ,MAAO,MACtBK,WAAeL,MAAO,MACtBM,SAAaN,MAAO,MACpBO,SAAaP,MAAO,MACpBQ,WAAeR,MAAO,MACtBS,eAAmBT,MAAO,MAE1BU,cAAkBV,MAAO,GAEzBW,mBAAuBX,MAAO,GAC9BY,oBAAwBZ,MAAO,GAE/Ba,SAAab,MAAO,IAAIR,MAAMsB,MAAO,WACrCC,UAAcf,MAAO,IAAIR,MAAMsB,MAAO,UACtCE,WAAehB,MAAO,IACtBiB,SAAajB,MAAO,GAEpBkB,aAAiBlB,MAAO,IAAIR,MAAM2B,QAAS,EAAG,IAC9CC,gBAAoBpB,MAAO,IAAIR,MAAM2B,QAAS,EAAG,IAEjDE,SAAarB,MAAO,IAAIR,MAAM2B,QAAS,EAAG,OAM5CG,gBAEC,wBACA,yBACA,2BACA,yBAEA,+BACA,+BACA,+BAEA,+BACA,+BACA,6BACA,6BACA,+BACA,mCAEA,8BAEA,+BACA,4BAEA,wBAEA,yBACA,0BACA,wBACA,oBAEA,8BAEA9B,MAAM+B,YAAsB,OAC5B/B,MAAM+B,YAAqB,MAC3B/B,MAAM+B,YAA2B,YACjC/B,MAAM+B,YAAuC,wBAC7C/B,MAAM+B,YAAiC,kBAEvC,iGACE,+BACC,mFACD,IACA,cACD,IAED,gBAEC,oCACA,gDAEA,kCAEA,mDACA,mCAEA,oEACA,gCACA,sCAEA,2CAEC,wDACA,wDAEA,qEACA,qEAEA,8FAED,iCAEC,qDAED,gCAEC,qDAED,IAEA,uBACC,uDAED,mDACA,sCAEA,0CACA,kDAEA,wCACA,yCAIA,2BAEC,kDAEC,gEAEA,oHAEA,kCAEA,8DAEA,yEACA,iEAEA,gGAEA,kFACA,oHAED,IAED,SAIA,yBAEC,iCACA,kCAEA,8CAEC,qDACA,8DAEA,qEACA,iEAEA,4FAEA,wEACA,wGAED,IAED,SAIA,0BAEC,mCACA,mCAEA,gDAEC,gDAIA,6CACA,oDAEA,oHAIA,kCAEA,gEACA,6EACA,4FAIA,iCAEA,yEACA,mFACA,+FAEA,yKAED,IAED,SAEA,sGAEA/B,MAAM+B,YAA4B,aAElC,wDAED,KAECC,KAAM,MAERC,cAEC,0BAEA,4BAEA,6BAEA,yBAEC,mCACA,oCACA,mCAED,SAEA,yBACA,0BACA,wBACA,oBAEA,8BAEAjC,MAAM+B,YAAqC,sBAE3C,gBAEC,gDAIA,sDAEA,sDACA,sCAIA,YAEA,kCAIA,yBAEC,oDACA,4DACA,mDAEA,qEACA,sEAED,QAEC,4DACA,6DAED,SAEA,+CAEA,mCAEA,iEACA,sCAEA/B,MAAM+B,YAAgC,iBAEvC,KAECC,KAAM","file":"../../threejs/ShaderTerrain.js","sourcesContent":["/**\n * @author alteredq / http://alteredqualia.com/\n *\n */\n\nTHREE.ShaderTerrain = {\n\n\t/* -------------------------------------------------------------------------\n\t//\tDynamic terrain shader\n\t//\t\t- Blinn-Phong\n\t//\t\t- height + normal + diffuse1 + diffuse2 + specular + detail maps\n\t//\t\t- point, directional and hemisphere lights (use with \"lights: true\" material option)\n\t//\t\t- shadow maps receiving\n\t ------------------------------------------------------------------------- */\n\n\t'terrain' : {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\n\t\t\t{\n\n\t\t\t\t\"enableDiffuse1\": { value: 0 },\n\t\t\t\t\"enableDiffuse2\": { value: 0 },\n\t\t\t\t\"enableSpecular\": { value: 0 },\n\t\t\t\t\"enableReflection\": { value: 0 },\n\n\t\t\t\t\"tDiffuse1\": { value: null },\n\t\t\t\t\"tDiffuse2\": { value: null },\n\t\t\t\t\"tDetail\": { value: null },\n\t\t\t\t\"tNormal\": { value: null },\n\t\t\t\t\"tSpecular\": { value: null },\n\t\t\t\t\"tDisplacement\": { value: null },\n\n\t\t\t\t\"uNormalScale\": { value: 1.0 },\n\n\t\t\t\t\"uDisplacementBias\": { value: 0.0 },\n\t\t\t\t\"uDisplacementScale\": { value: 1.0 },\n\n\t\t\t\t\"diffuse\": { value: new THREE.Color( 0xeeeeee ) },\n\t\t\t\t\"specular\": { value: new THREE.Color( 0x111111 ) },\n\t\t\t\t\"shininess\": { value: 30 },\n\t\t\t\t\"opacity\": { value: 1 },\n\n\t\t\t\t\"uRepeatBase\": { value: new THREE.Vector2( 1, 1 ) },\n\t\t\t\t\"uRepeatOverlay\": { value: new THREE.Vector2( 1, 1 ) },\n\n\t\t\t\t\"uOffset\": { value: new THREE.Vector2( 0, 0 ) }\n\n\t\t\t}\n\n\t\t] ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 diffuse;\",\n\t\t\t\"uniform vec3 specular;\",\n\t\t\t\"uniform float shininess;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"uniform bool enableDiffuse1;\",\n\t\t\t\"uniform bool enableDiffuse2;\",\n\t\t\t\"uniform bool enableSpecular;\",\n\n\t\t\t\"uniform sampler2D tDiffuse1;\",\n\t\t\t\"uniform sampler2D tDiffuse2;\",\n\t\t\t\"uniform sampler2D tDetail;\",\n\t\t\t\"uniform sampler2D tNormal;\",\n\t\t\t\"uniform sampler2D tSpecular;\",\n\t\t\t\"uniform sampler2D tDisplacement;\",\n\n\t\t\t\"uniform float uNormalScale;\",\n\n\t\t\t\"uniform vec2 uRepeatOverlay;\",\n\t\t\t\"uniform vec2 uRepeatBase;\",\n\n\t\t\t\"uniform vec2 uOffset;\",\n\n\t\t\t\"varying vec3 vTangent;\",\n\t\t\t\"varying vec3 vBinormal;\",\n\t\t\t\"varying vec3 vNormal;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"varying vec3 vViewPosition;\",\n\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\n\t\t\tTHREE.ShaderChunk[ \"bsdfs\" ],\n\t\t\tTHREE.ShaderChunk[ \"lights_pars\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\n\t\t\t\"float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\",\n \t\t\t\t\"if ( decayExponent > 0.0 ) {\",\n \t\t\t\t\t\"return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\",\n \t\t\t\t\"}\",\n \t\t\t\t\"return 1.0;\",\n \t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\n\t\t\t\t\"vec4 diffuseColor = vec4( diffuse, opacity );\",\n\n\t\t\t\t\"vec3 specularTex = vec3( 1.0 );\",\n\n\t\t\t\t\"vec2 uvOverlay = uRepeatOverlay * vUv + uOffset;\",\n\t\t\t\t\"vec2 uvBase = uRepeatBase * vUv;\",\n\n\t\t\t\t\"vec3 normalTex = texture2D( tDetail, uvOverlay ).xyz * 2.0 - 1.0;\",\n\t\t\t\t\"normalTex.xy *= uNormalScale;\",\n\t\t\t\t\"normalTex = normalize( normalTex );\",\n\n\t\t\t\t\"if( enableDiffuse1 && enableDiffuse2 ) {\",\n\n\t\t\t\t\t\"vec4 colDiffuse1 = texture2D( tDiffuse1, uvOverlay );\",\n\t\t\t\t\t\"vec4 colDiffuse2 = texture2D( tDiffuse2, uvOverlay );\",\n\n\t\t\t\t\t\"colDiffuse1 = GammaToLinear( colDiffuse1, float( GAMMA_FACTOR ) );\",\n\t\t\t\t\t\"colDiffuse2 = GammaToLinear( colDiffuse2, float( GAMMA_FACTOR ) );\",\n\n\t\t\t\t\t\"diffuseColor *= mix ( colDiffuse1, colDiffuse2, 1.0 - texture2D( tDisplacement, uvBase ) );\",\n\n\t\t\t\t\" } else if( enableDiffuse1 ) {\",\n\n\t\t\t\t\t\"diffuseColor *= texture2D( tDiffuse1, uvOverlay );\",\n\n\t\t\t\t\"} else if( enableDiffuse2 ) {\",\n\n\t\t\t\t\t\"diffuseColor *= texture2D( tDiffuse2, uvOverlay );\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"if( enableSpecular )\",\n\t\t\t\t\t\"specularTex = texture2D( tSpecular, uvOverlay ).xyz;\",\n\n\t\t\t\t\"mat3 tsb = mat3( vTangent, vBinormal, vNormal );\",\n\t\t\t\t\"vec3 finalNormal = tsb * normalTex;\",\n\n\t\t\t\t\"vec3 normal = normalize( finalNormal );\",\n\t\t\t\t\"vec3 viewPosition = normalize( vViewPosition );\",\n\n\t\t\t\t\"vec3 totalDiffuseLight = vec3( 0.0 );\",\n\t\t\t\t\"vec3 totalSpecularLight = vec3( 0.0 );\",\n\n\t\t\t\t// point lights\n\n\t\t\t\t\"#if NUM_POINT_LIGHTS > 0\",\n\n\t\t\t\t\t\"for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\t\t\"vec3 lVector = pointLights[ i ].position + vViewPosition.xyz;\",\n\n\t\t\t\t\t\t\"float attenuation = calcLightAttenuation( length( lVector ), pointLights[ i ].distance, pointLights[ i ].decay );\",\n\n\t\t\t\t\t\t\"lVector = normalize( lVector );\",\n\n\t\t\t\t\t\t\"vec3 pointHalfVector = normalize( lVector + viewPosition );\",\n\n\t\t\t\t\t\t\"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\",\n\t\t\t\t\t\t\"float pointDiffuseWeight = max( dot( normal, lVector ), 0.0 );\",\n\n\t\t\t\t\t\t\"float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\",\n\n\t\t\t\t\t\t\"totalDiffuseLight += attenuation * pointLights[ i ].color * pointDiffuseWeight;\",\n\t\t\t\t\t\t\"totalSpecularLight += attenuation * pointLights[ i ].color * specular * pointSpecularWeight * pointDiffuseWeight;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// directional lights\n\n\t\t\t\t\"#if NUM_DIR_LIGHTS > 0\",\n\n\t\t\t\t\t\"vec3 dirDiffuse = vec3( 0.0 );\",\n\t\t\t\t\t\"vec3 dirSpecular = vec3( 0.0 );\",\n\n\t\t\t\t\t\"for( int i = 0; i < NUM_DIR_LIGHTS; i++ ) {\",\n\n\t\t\t\t\t\t\"vec3 dirVector = directionalLights[ i ].direction;\",\n\t\t\t\t\t\t\"vec3 dirHalfVector = normalize( dirVector + viewPosition );\",\n\n\t\t\t\t\t\t\"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\",\n\t\t\t\t\t\t\"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\",\n\n\t\t\t\t\t\t\"float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\",\n\n\t\t\t\t\t\t\"totalDiffuseLight += directionalLights[ i ].color * dirDiffuseWeight;\",\n\t\t\t\t\t\t\"totalSpecularLight += directionalLights[ i ].color * specular * dirSpecularWeight * dirDiffuseWeight;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// hemisphere lights\n\n\t\t\t\t\"#if NUM_HEMI_LIGHTS > 0\",\n\n\t\t\t\t\t\"vec3 hemiDiffuse  = vec3( 0.0 );\",\n\t\t\t\t\t\"vec3 hemiSpecular = vec3( 0.0 );\",\n\n\t\t\t\t\t\"for( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\t\t\"vec3 lVector = hemisphereLightDirection[ i ];\",\n\n\t\t\t\t\t\t// diffuse\n\n\t\t\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\t\t\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\n\n\t\t\t\t\t\t\"totalDiffuseLight += mix( hemisphereLights[ i ].groundColor, hemisphereLights[ i ].skyColor, hemiDiffuseWeight );\",\n\n\t\t\t\t\t\t// specular (sky light)\n\n\t\t\t\t\t\t\"float hemiSpecularWeight = 0.0;\",\n\n\t\t\t\t\t\t\"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\",\n\t\t\t\t\t\t\"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\",\n\t\t\t\t\t\t\"hemiSpecularWeight += specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\",\n\n\t\t\t\t\t\t// specular (ground light)\n\n\t\t\t\t\t\t\"vec3 lVectorGround = -lVector;\",\n\n\t\t\t\t\t\t\"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\",\n\t\t\t\t\t\t\"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\",\n\t\t\t\t\t\t\"hemiSpecularWeight += specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\",\n\n\t\t\t\t\t\t\"totalSpecularLight += specular * mix( hemisphereLights[ i ].groundColor, hemisphereLights[ i ].skyColor, hemiDiffuseWeight ) * hemiSpecularWeight * hemiDiffuseWeight;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"outgoingLight += diffuseColor.xyz * ( totalDiffuseLight + ambientLightColor + totalSpecularLight );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\t\"gl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tvertexShader: [\n\n\t\t\t\"attribute vec4 tangent;\",\n\n\t\t\t\"uniform vec2 uRepeatBase;\",\n\n\t\t\t\"uniform sampler2D tNormal;\",\n\n\t\t\t\"#ifdef VERTEX_TEXTURES\",\n\n\t\t\t\t\"uniform sampler2D tDisplacement;\",\n\t\t\t\t\"uniform float uDisplacementScale;\",\n\t\t\t\t\"uniform float uDisplacementBias;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"varying vec3 vTangent;\",\n\t\t\t\"varying vec3 vBinormal;\",\n\t\t\t\"varying vec3 vNormal;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"varying vec3 vViewPosition;\",\n\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\n\n\t\t\t\t// tangent and binormal vectors\n\n\t\t\t\t\"vTangent = normalize( normalMatrix * tangent.xyz );\",\n\n\t\t\t\t\"vBinormal = cross( vNormal, vTangent ) * tangent.w;\",\n\t\t\t\t\"vBinormal = normalize( vBinormal );\",\n\n\t\t\t\t// texture coordinates\n\n\t\t\t\t\"vUv = uv;\",\n\n\t\t\t\t\"vec2 uvBase = uv * uRepeatBase;\",\n\n\t\t\t\t// displacement mapping\n\n\t\t\t\t\"#ifdef VERTEX_TEXTURES\",\n\n\t\t\t\t\t\"vec3 dv = texture2D( tDisplacement, uvBase ).xyz;\",\n\t\t\t\t\t\"float df = uDisplacementScale * dv.x + uDisplacementBias;\",\n\t\t\t\t\t\"vec3 displacedPosition = normal * df + position;\",\n\n\t\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\",\n\t\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n\t\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\n\n\t\t\t\t\"vec3 normalTex = texture2D( tNormal, uvBase ).xyz * 2.0 - 1.0;\",\n\t\t\t\t\"vNormal = normalMatrix * normalTex;\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t}\n\n};\n"]}