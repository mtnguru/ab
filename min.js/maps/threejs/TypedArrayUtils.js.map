{"version":3,"sources":["threejs/TypedArrayUtils.js"],"names":["THREE","TypedArrayUtils","quicksortIP","arr","eleSize","orderElement","i","j","stack","sp","left","right","length","tmp","x","y","swapF","a","b","swap","Float32Array","temp","Kdtree","points","metric","buildTree","depth","parent","pos","median","node","dim","plength","maxDepth","self","Node","getPointSet","Math","floor","subarray","this","root","getMaxDepth","nearest","point","maxNodes","maxDistance","nearestSearch","saveNode","distance","bestNodes","push","size","pop","bestChild","otherChild","dimension","ownDistance","obj","linearDistance","linearPoint","peek","abs","result","BinaryHeap","e","content","prototype","scoreFunction","element","bubbleUp","end","sinkDown","remove","len","Error","n","parentN","elemScore","child2N","child1N","child1","child1Score","child2"],"mappings":"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","file":"../../threejs/TypedArrayUtils.js","sourcesContent":["\nTHREE.TypedArrayUtils = {};\n\n/**\n * In-place quicksort for typed arrays (e.g. for Float32Array)\n * provides fast sorting\n * useful e.g. for a custom shader and/or BufferGeometry\n *\n * @author Roman Bolzern <roman.bolzern@fhnw.ch>, 2013\n * @author I4DS http://www.fhnw.ch/i4ds, 2013\n * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\n *\n * Complexity: http://bigocheatsheet.com/ see Quicksort\n *\n * Example: \n * points: [x, y, z, x, y, z, x, y, z, ...]\n * eleSize: 3 //because of (x, y, z)\n * orderElement: 0 //order according to x\n */\n\nTHREE.TypedArrayUtils.quicksortIP = function ( arr, eleSize, orderElement ) {\n\n\tvar stack = [];\n\tvar sp = - 1;\n\tvar left = 0;\n\tvar right = arr.length / eleSize - 1;\n\tvar tmp = 0.0, x = 0, y = 0;\n\n\tvar swapF = function ( a, b ) {\n\n\t\ta *= eleSize; b *= eleSize;\n\n\t\tfor ( y = 0; y < eleSize; y ++ ) {\n\n\t\t\ttmp = arr[ a + y ];\n\t\t\tarr[ a + y ] = arr[ b + y ];\n\t\t\tarr[ b + y ] = tmp;\n\n\t\t}\n\n\t};\n\t\n\tvar i, j, swap = new Float32Array( eleSize ), temp = new Float32Array( eleSize );\n\n\twhile ( true ) {\n\n\t\tif ( right - left <= 25 ) {\n\n\t\t\tfor ( j = left + 1; j <= right; j ++ ) {\n\n\t\t\t\tfor ( x = 0; x < eleSize; x ++ ) {\n\t\t\t\n\t\t\t\t\tswap[ x ] = arr[ j * eleSize + x ];\n\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ti = j - 1;\n\t\t\t\t\n\t\t\t\twhile ( i >= left && arr[ i * eleSize + orderElement ] > swap[ orderElement ] ) {\n\n\t\t\t\t\tfor ( x = 0; x < eleSize; x ++ ) {\n\n\t\t\t\t\t\tarr[ ( i + 1 ) * eleSize + x ] = arr[ i * eleSize + x ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\ti --;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( x = 0; x < eleSize; x ++ ) {\n\n\t\t\t\t\tarr[ ( i + 1 ) * eleSize + x ] = swap[ x ];\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\t\t\tif ( sp == - 1 ) break;\n\n\t\t\tright = stack[ sp -- ]; //?\n\t\t\tleft = stack[ sp -- ];\n\n\t\t} else {\n\n\t\t\tvar median = ( left + right ) >> 1;\n\n\t\t\ti = left + 1;\n\t\t\tj = right;\n\t\n\t\t\tswapF( median, i );\n\n\t\t\tif ( arr[ left * eleSize + orderElement ] > arr[ right * eleSize + orderElement ] ) {\n\t\t\n\t\t\t\tswapF( left, right );\n\t\t\t\t\n\t\t\t}\n\n\t\t\tif ( arr[ i * eleSize + orderElement ] > arr[ right * eleSize + orderElement ] ) {\n\t\t\n\t\t\t\tswapF( i, right );\n\t\t\n\t\t\t}\n\n\t\t\tif ( arr[ left * eleSize + orderElement ] > arr[ i * eleSize + orderElement ] ) {\n\t\t\n\t\t\t\tswapF( left, i );\n\t\t\t\n\t\t\t}\n\n\t\t\tfor ( x = 0; x < eleSize; x ++ ) {\n\n\t\t\t\ttemp[ x ] = arr[ i * eleSize + x ];\n\n\t\t\t}\n\t\t\t\n\t\t\twhile ( true ) {\n\t\t\t\t\n\t\t\t\tdo i ++; while ( arr[ i * eleSize + orderElement ] < temp[ orderElement ] );\n\t\t\t\tdo j --; while ( arr[ j * eleSize + orderElement ] > temp[ orderElement ] );\n\t\t\t\t\n\t\t\t\tif ( j < i ) break;\n\t\t\n\t\t\t\tswapF( i, j );\n\t\t\t\n\t\t\t}\n\n\t\t\tfor ( x = 0; x < eleSize; x ++ ) {\n\n\t\t\t\tarr[ ( left + 1 ) * eleSize + x ] = arr[ j * eleSize + x ];\n\t\t\t\tarr[ j * eleSize + x ] = temp[ x ];\n\n\t\t\t}\n\n\t\t\tif ( right - i + 1 >= j - left ) {\n\n\t\t\t\tstack[ ++ sp ] = i;\n\t\t\t\tstack[ ++ sp ] = right;\n\t\t\t\tright = j - 1;\n\n\t\t\t} else {\n\n\t\t\t\tstack[ ++ sp ] = left;\n\t\t\t\tstack[ ++ sp ] = j - 1;\n\t\t\t\tleft = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn arr;\n\n};\n\n\n\n/**\n * k-d Tree for typed arrays (e.g. for Float32Array), in-place\n * provides fast nearest neighbour search\n * useful e.g. for a custom shader and/or BufferGeometry, saves tons of memory\n * has no insert and remove, only buildup and neares neighbour search\n *\n * Based on https://github.com/ubilabs/kd-tree-javascript by Ubilabs\n *\n * @author Roman Bolzern <roman.bolzern@fhnw.ch>, 2013\n * @author I4DS http://www.fhnw.ch/i4ds, 2013\n * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\n *\n * Requires typed array quicksort\n *\n * Example: \n * points: [x, y, z, x, y, z, x, y, z, ...]\n * metric: function(a, b){\treturn Math.pow(a[0] - b[0], 2) +  Math.pow(a[1] - b[1], 2) +  Math.pow(a[2] - b[2], 2); }  //Manhatten distance\n * eleSize: 3 //because of (x, y, z)\n *\n * Further information (including mathematical properties)\n * http://en.wikipedia.org/wiki/Binary_tree\n * http://en.wikipedia.org/wiki/K-d_tree\n *\n * If you want to further minimize memory usage, remove Node.depth and replace in search algorithm with a traversal to root node (see comments at THREE.TypedArrayUtils.Kdtree.prototype.Node)\n */\n\n THREE.TypedArrayUtils.Kdtree = function ( points, metric, eleSize ) {\n\n\tvar self = this;\n\t\n\tvar maxDepth = 0;\n\t\n\tvar getPointSet = function ( points, pos ) {\n\n\t\treturn points.subarray( pos * eleSize, pos * eleSize + eleSize );\n\n\t};\n\t\t\n\tfunction buildTree( points, depth, parent, pos ) {\n\n\t\tvar dim = depth % eleSize,\n\t\t\tmedian,\n\t\t\tnode,\n\t\t\tplength = points.length / eleSize;\n\n\t\tif ( depth > maxDepth ) maxDepth = depth;\n\t\t\n\t\tif ( plength === 0 ) return null;\n\t\tif ( plength === 1 ) {\n\n\t\t\treturn new self.Node( getPointSet( points, 0 ), depth, parent, pos );\n\n\t\t}\n\n\t\tTHREE.TypedArrayUtils.quicksortIP( points, eleSize, dim );\n\t\t\n\t\tmedian = Math.floor( plength / 2 );\n\t\t\n\t\tnode = new self.Node( getPointSet( points, median ), depth, parent, median + pos );\n\t\tnode.left = buildTree( points.subarray( 0, median * eleSize ), depth + 1, node, pos );\n\t\tnode.right = buildTree( points.subarray( ( median + 1 ) * eleSize, points.length ), depth + 1, node, pos + median + 1 );\n\n\t\treturn node;\n\t\n\t}\n\n\tthis.root = buildTree( points, 0, null, 0 );\n\t\t\n\tthis.getMaxDepth = function () {\n\n\t\treturn maxDepth;\n\n\t};\n\t\n\tthis.nearest = function ( point, maxNodes, maxDistance ) {\n\t\n\t\t /* point: array of size eleSize \n\t\t\tmaxNodes: max amount of nodes to return \n\t\t\tmaxDistance: maximum distance to point result nodes should have\n\t\t\tcondition (not implemented): function to test node before it's added to the result list, e.g. test for view frustum\n\t\t*/\n\n\t\tvar i,\n\t\t\tresult,\n\t\t\tbestNodes;\n\n\t\tbestNodes = new THREE.TypedArrayUtils.Kdtree.BinaryHeap(\n\n\t\t\tfunction ( e ) {\n\n\t\t\t\treturn - e[ 1 ];\n\n\t\t\t}\n\n\t\t\t\t\t);\n\n\t\tfunction nearestSearch( node ) {\n\n\t\t\tvar bestChild,\n\t\t\t\tdimension = node.depth % eleSize,\n\t\t\t\townDistance = metric( point, node.obj ),\n\t\t\t\tlinearDistance = 0,\n\t\t\t\totherChild,\n\t\t\t\ti,\n\t\t\t\tlinearPoint = [];\n\n\t\t\tfunction saveNode( node, distance ) {\n\n\t\t\t\tbestNodes.push( [ node, distance ] );\n\n\t\t\t\tif ( bestNodes.size() > maxNodes ) {\n\n\t\t\t\t\tbestNodes.pop();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < eleSize; i += 1 ) {\n\n\t\t\t\tif ( i === node.depth % eleSize ) {\n\n\t\t\t\t\tlinearPoint[ i ] = point[ i ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlinearPoint[ i ] = node.obj[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlinearDistance = metric( linearPoint, node.obj );\n\n\t\t\t// if it's a leaf\n\n\t\t\tif ( node.right === null && node.left === null ) {\n\n\t\t\t\tif ( bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[ 1 ] ) {\n\n\t\t\t\t\tsaveNode( node, ownDistance );\n\n\t\t\t\t}\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( node.right === null ) {\n\n\t\t\t\tbestChild = node.left;\n\n\t\t\t} else if ( node.left === null ) {\n\n\t\t\t\tbestChild = node.right;\n\n\t\t\t} else {\n\n\t\t\t\tif ( point[ dimension ] < node.obj[ dimension ] ) {\n\n\t\t\t\t\tbestChild = node.left;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbestChild = node.right;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// recursive search\n\n\t\t\tnearestSearch( bestChild );\n\n\t\t\tif ( bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[ 1 ] ) {\n\n\t\t\t\tsaveNode( node, ownDistance );\n\n\t\t\t}\n\n\t\t\t// if there's still room or the current distance is nearer than the best distance\n\n\t\t\tif ( bestNodes.size() < maxNodes || Math.abs( linearDistance ) < bestNodes.peek()[ 1 ] ) {\n\n\t\t\t\tif ( bestChild === node.left ) {\n\n\t\t\t\t\totherChild = node.right;\n\n\t\t\t\t} else {\n\n\t\t\t\t\totherChild = node.left;\n\n\t\t\t\t}\n\n\t\t\t\tif ( otherChild !== null ) {\n\n\t\t\t\t\tnearestSearch( otherChild );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( maxDistance ) {\n\n\t\t\tfor ( i = 0; i < maxNodes; i += 1 ) {\n\n\t\t\t\tbestNodes.push( [ null, maxDistance ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tnearestSearch( self.root );\n\n\t\tresult = [];\n\n\t\tfor ( i = 0; i < maxNodes; i += 1 ) {\n\n\t\t\tif ( bestNodes.content[ i ][ 0 ] ) {\n\n\t\t\t\tresult.push( [ bestNodes.content[ i ][ 0 ], bestNodes.content[ i ][ 1 ] ] );\n\n\t\t\t}\n\n\t\t}\n\t\t\n\t\treturn result;\n\t\n\t};\n\t\n};\n\n/**\n * If you need to free up additional memory and agree with an additional O( log n ) traversal time you can get rid of \"depth\" and \"pos\" in Node:\n * Depth can be easily done by adding 1 for every parent (care: root node has depth 0, not 1)\n * Pos is a bit tricky: Assuming the tree is balanced (which is the case when after we built it up), perform the following steps:\n *   By traversing to the root store the path e.g. in a bit pattern (01001011, 0 is left, 1 is right)\n *   From buildTree we know that \"median = Math.floor( plength / 2 );\", therefore for each bit...\n *     0: amountOfNodesRelevantForUs = Math.floor( (pamountOfNodesRelevantForUs - 1) / 2 );\n *     1: amountOfNodesRelevantForUs = Math.ceil( (pamountOfNodesRelevantForUs - 1) / 2 );\n *        pos += Math.floor( (pamountOfNodesRelevantForUs - 1) / 2 );\n *     when recursion done, we still need to add all left children of target node:\n *        pos += Math.floor( (pamountOfNodesRelevantForUs - 1) / 2 );\n *        and I think you need to +1 for the current position, not sure.. depends, try it out ^^\n *\n * I experienced that for 200'000 nodes you can get rid of 4 MB memory each, leading to 8 MB memory saved.\n */\nTHREE.TypedArrayUtils.Kdtree.prototype.Node = function ( obj, depth, parent, pos ) {\n\n\tthis.obj = obj;\n\tthis.left = null;\n\tthis.right = null;\n\tthis.parent = parent;\n\tthis.depth = depth;\n\tthis.pos = pos;\n\n}; \n\n/**\n * Binary heap implementation\n * @author http://eloquentjavascript.net/appendix2.htm\n */\n\nTHREE.TypedArrayUtils.Kdtree.BinaryHeap = function ( scoreFunction ) {\n\n\tthis.content = [];\n\tthis.scoreFunction = scoreFunction;\n\n};\n\nTHREE.TypedArrayUtils.Kdtree.BinaryHeap.prototype = {\n\n\tpush: function ( element ) {\n\n\t\t// Add the new element to the end of the array.\n\t\tthis.content.push( element );\n\n\t\t// Allow it to bubble up.\n\t\tthis.bubbleUp( this.content.length - 1 );\n\n\t},\n\n\tpop: function () {\n\n\t\t// Store the first element so we can return it later.\n\t\tvar result = this.content[ 0 ];\n\n\t\t// Get the element at the end of the array.\n\t\tvar end = this.content.pop();\n\n\t\t// If there are any elements left, put the end element at the\n\t\t// start, and let it sink down.\n\t\tif ( this.content.length > 0 ) {\n\n\t\t\tthis.content[ 0 ] = end;\n\t\t\tthis.sinkDown( 0 );\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\tpeek: function () {\n\n\t\treturn this.content[ 0 ];\n\n\t},\n\n\tremove: function ( node ) {\n\n\t\tvar len = this.content.length;\n\n\t\t// To remove a value, we must search through the array to find it.\n\t\tfor ( var i = 0; i < len; i ++ ) {\n\n\t\t\tif ( this.content[ i ] == node ) {\n\n\t\t\t\t// When it is found, the process seen in 'pop' is repeated\n\t\t\t\t// to fill up the hole.\n\t\t\t\tvar end = this.content.pop();\n\n\t\t\t\tif ( i != len - 1 ) {\n\n\t\t\t\t\tthis.content[ i ] = end;\n\n\t\t\t\t\tif ( this.scoreFunction( end ) < this.scoreFunction( node ) ) {\n\n\t\t\t\t\t\tthis.bubbleUp( i );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.sinkDown( i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthrow new Error( \"Node not found.\" );\n\n\t},\n\n\tsize: function () {\n\n\t\treturn this.content.length;\n\n\t},\n\n\tbubbleUp: function ( n ) {\n\n\t\t// Fetch the element that has to be moved.\n\t\tvar element = this.content[ n ];\n\n\t\t// When at 0, an element can not go up any further.\n\t\twhile ( n > 0 ) {\n\n\t\t\t// Compute the parent element's index, and fetch it.\n\t\t\tvar parentN = Math.floor( ( n + 1 ) / 2 ) - 1,\n\t\t\t\tparent = this.content[ parentN ];\n\n\t\t\t// Swap the elements if the parent is greater.\n\t\t\tif ( this.scoreFunction( element ) < this.scoreFunction( parent ) ) {\n\n\t\t\t\tthis.content[ parentN ] = element;\n\t\t\t\tthis.content[ n ] = parent;\n\n\t\t\t\t// Update 'n' to continue at the new position.\n\t\t\t\tn = parentN;\n\n\t\t\t} else {\n\n\t\t\t\t// Found a parent that is less, no need to move it further.\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tsinkDown: function ( n ) {\n\n\t\t// Look up the target element and its score.\n\t\tvar length = this.content.length,\n\t\t\telement = this.content[ n ],\n\t\t\telemScore = this.scoreFunction( element );\n\n\t\twhile ( true ) {\n\n\t\t\t// Compute the indices of the child elements.\n\t\t\tvar child2N = ( n + 1 ) * 2, child1N = child2N - 1;\n\n\t\t\t// This is used to store the new position of the element, if any.\n\t\t\tvar swap = null;\n\n\t\t\t// If the first child exists (is inside the array)...\n\t\t\tif ( child1N < length ) {\n\n\t\t\t\t// Look it up and compute its score.\n\t\t\t\tvar child1 = this.content[ child1N ],\n\t\t\t\t\tchild1Score = this.scoreFunction( child1 );\n\n\t\t\t\t// If the score is less than our element's, we need to swap.\n\t\t\t\tif ( child1Score < elemScore ) swap = child1N;\n\n\t\t\t}\n\n\t\t\t// Do the same checks for the other child.\n\t\t\tif ( child2N < length ) {\n\n\t\t\t\tvar child2 = this.content[ child2N ],\n\t\t\t\t\tchild2Score = this.scoreFunction( child2 );\n\n\t\t\t\tif ( child2Score < ( swap === null ? elemScore : child1Score ) ) swap = child2N;\n\n\t\t\t}\n\n\t\t\t// If the element needs to be moved, swap it, and continue.\n\t\t\tif ( swap !== null ) {\n\n\t\t\t\tthis.content[ n ] = this.content[ swap ];\n\t\t\t\tthis.content[ swap ] = element;\n\t\t\t\tn = swap;\n\n\t\t\t} else {\n\n\t\t\t\t// Otherwise, we are done.\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n"]}