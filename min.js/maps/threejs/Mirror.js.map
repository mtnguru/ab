{"version":3,"sources":["threejs/Mirror.js"],"names":["THREE","ShaderLib","uniforms","mirrorColor","value","Color","mirrorSampler","textureMatrix","Matrix4","vertexShader","join","fragmentShader","Mirror","renderer","camera","options","Object3D","call","this","name","id","matrixNeedsUpdate","width","undefined","textureWidth","height","textureHeight","clipBias","color","mirrorPlane","Plane","normal","Vector3","mirrorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","Vector4","debugMode","arrow","ArrowHelper","planeGeometry","Geometry","vertices","push","plane","Line","LineBasicMaterial","add","PerspectiveCamera","console","log","mirrorCamera","clone","matrixAutoUpdate","parameters","minFilter","LinearFilter","magFilter","format","RGBFormat","stencilBuffer","renderTarget","WebGLRenderTarget","renderTarget2","mirrorShader","mirrorUniforms","UniformsUtils","material","ShaderMaterial","texture","Math","isPowerOfTwo","generateMipmaps","updateTextureMatrix","render","prototype","Object","create","constructor","renderWithMirror","otherMirror","tempCamera","renderTemp","updateMatrixWorld","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","view","sub","reflect","negate","target","up","position","copy","lookAt","updateProjectionMatrix","matrixWorldInverse","getInverse","multiply","projectionMatrix","setFromNormalAndCoplanarPoint","x","y","z","constant","q","sign","elements","w","c","multiplyScalar","dot","scene","parent","Scene","visible"],"mappings":"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","file":"../../threejs/Mirror.js","sourcesContent":["/**\r\n * @author Slayvin / http://slayvin.net\r\n */\r\n\r\nTHREE.ShaderLib[ 'mirror' ] = {\r\n\r\n\tuniforms: {\r\n\t\t\"mirrorColor\": { value: new THREE.Color( 0x7F7F7F ) },\r\n\t\t\"mirrorSampler\": { value: null },\r\n\t\t\"textureMatrix\" : { value: new THREE.Matrix4() }\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"uniform mat4 textureMatrix;\",\r\n\r\n\t\t\"varying vec4 mirrorCoord;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\"mirrorCoord = textureMatrix * worldPosition;\",\r\n\r\n\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform vec3 mirrorColor;\",\r\n\t\t\"uniform sampler2D mirrorSampler;\",\r\n\r\n\t\t\"varying vec4 mirrorCoord;\",\r\n\r\n\t\t\"float blendOverlay(float base, float blend) {\",\r\n\t\t\t\"return( base < 0.5 ? ( 2.0 * base * blend ) : (1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\",\r\n\t\t\"}\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec4 color = texture2DProj(mirrorSampler, mirrorCoord);\",\r\n\t\t\t\"color = vec4(blendOverlay(mirrorColor.r, color.r), blendOverlay(mirrorColor.g, color.g), blendOverlay(mirrorColor.b, color.b), 1.0);\",\r\n\r\n\t\t\t\"gl_FragColor = color;\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join( \"\\n\" )\r\n\r\n};\r\n\r\nTHREE.Mirror = function ( renderer, camera, options ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.name = 'mirror_' + this.id;\r\n\r\n\toptions = options || {};\r\n\r\n\tthis.matrixNeedsUpdate = true;\r\n\r\n\tvar width = options.textureWidth !== undefined ? options.textureWidth : 512;\r\n\tvar height = options.textureHeight !== undefined ? options.textureHeight : 512;\r\n\r\n\tthis.clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\r\n\r\n\tvar mirrorColor = options.color !== undefined ? new THREE.Color( options.color ) : new THREE.Color( 0x7F7F7F );\r\n\r\n\tthis.renderer = renderer;\r\n\tthis.mirrorPlane = new THREE.Plane();\r\n\tthis.normal = new THREE.Vector3( 0, 0, 1 );\r\n\tthis.mirrorWorldPosition = new THREE.Vector3();\r\n\tthis.cameraWorldPosition = new THREE.Vector3();\r\n\tthis.rotationMatrix = new THREE.Matrix4();\r\n\tthis.lookAtPosition = new THREE.Vector3( 0, 0, - 1 );\r\n\tthis.clipPlane = new THREE.Vector4();\r\n\r\n\t// For debug only, show the normal and plane of the mirror\r\n\tvar debugMode = options.debugMode !== undefined ? options.debugMode : false;\r\n\r\n\tif ( debugMode ) {\r\n\r\n\t\tvar arrow = new THREE.ArrowHelper( new THREE.Vector3( 0, 0, 1 ), new THREE.Vector3( 0, 0, 0 ), 10, 0xffff80 );\r\n\t\tvar planeGeometry = new THREE.Geometry();\r\n\t\tplaneGeometry.vertices.push( new THREE.Vector3( - 10, - 10, 0 ) );\r\n\t\tplaneGeometry.vertices.push( new THREE.Vector3( 10, - 10, 0 ) );\r\n\t\tplaneGeometry.vertices.push( new THREE.Vector3( 10, 10, 0 ) );\r\n\t\tplaneGeometry.vertices.push( new THREE.Vector3( - 10, 10, 0 ) );\r\n\t\tplaneGeometry.vertices.push( planeGeometry.vertices[ 0 ] );\r\n\t\tvar plane = new THREE.Line( planeGeometry, new THREE.LineBasicMaterial( { color: 0xffff80 } ) );\r\n\r\n\t\tthis.add( arrow );\r\n\t\tthis.add( plane );\r\n\r\n\t}\r\n\r\n\tif ( camera instanceof THREE.PerspectiveCamera ) {\r\n\r\n\t\tthis.camera = camera;\r\n\r\n\t} else {\r\n\r\n\t\tthis.camera = new THREE.PerspectiveCamera();\r\n\t\tconsole.log( this.name + ': camera is not a Perspective Camera!' );\r\n\r\n\t}\r\n\r\n\tthis.textureMatrix = new THREE.Matrix4();\r\n\r\n\tthis.mirrorCamera = this.camera.clone();\r\n\tthis.mirrorCamera.matrixAutoUpdate = true;\r\n\r\n\tvar parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };\r\n\r\n\tthis.renderTarget = new THREE.WebGLRenderTarget( width, height, parameters );\r\n\tthis.renderTarget2 = new THREE.WebGLRenderTarget( width, height, parameters );\r\n\r\n\tvar mirrorShader = THREE.ShaderLib[ \"mirror\" ];\r\n\tvar mirrorUniforms = THREE.UniformsUtils.clone( mirrorShader.uniforms );\r\n\r\n\tthis.material = new THREE.ShaderMaterial( {\r\n\r\n\t\tfragmentShader: mirrorShader.fragmentShader,\r\n\t\tvertexShader: mirrorShader.vertexShader,\r\n\t\tuniforms: mirrorUniforms\r\n\r\n\t} );\r\n\r\n\tthis.material.uniforms.mirrorSampler.value = this.renderTarget.texture;\r\n\tthis.material.uniforms.mirrorColor.value = mirrorColor;\r\n\tthis.material.uniforms.textureMatrix.value = this.textureMatrix;\r\n\r\n\tif ( ! THREE.Math.isPowerOfTwo( width ) || ! THREE.Math.isPowerOfTwo( height ) ) {\r\n\r\n\t\tthis.renderTarget.texture.generateMipmaps = false;\r\n\t\tthis.renderTarget2.texture.generateMipmaps = false;\r\n\r\n\t}\r\n\r\n\tthis.updateTextureMatrix();\r\n\tthis.render();\r\n\r\n};\r\n\r\nTHREE.Mirror.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Mirror.prototype.constructor = THREE.Mirror;\r\n\r\nTHREE.Mirror.prototype.renderWithMirror = function ( otherMirror ) {\r\n\r\n\t// update the mirror matrix to mirror the current view\r\n\tthis.updateTextureMatrix();\r\n\tthis.matrixNeedsUpdate = false;\r\n\r\n\t// set the camera of the other mirror so the mirrored view is the reference view\r\n\tvar tempCamera = otherMirror.camera;\r\n\totherMirror.camera = this.mirrorCamera;\r\n\r\n\t// render the other mirror in temp texture\r\n\totherMirror.renderTemp();\r\n\totherMirror.material.uniforms.mirrorSampler.value = otherMirror.renderTarget2.texture;\r\n\r\n\t// render the current mirror\r\n\tthis.render();\r\n\tthis.matrixNeedsUpdate = true;\r\n\r\n\t// restore material and camera of other mirror\r\n\totherMirror.material.uniforms.mirrorSampler.value = otherMirror.renderTarget.texture;\r\n\totherMirror.camera = tempCamera;\r\n\r\n\t// restore texture matrix of other mirror\r\n\totherMirror.updateTextureMatrix();\r\n\r\n};\r\n\r\nTHREE.Mirror.prototype.updateTextureMatrix = function () {\r\n\r\n\tthis.updateMatrixWorld();\r\n\tthis.camera.updateMatrixWorld();\r\n\r\n\tthis.mirrorWorldPosition.setFromMatrixPosition( this.matrixWorld );\r\n\tthis.cameraWorldPosition.setFromMatrixPosition( this.camera.matrixWorld );\r\n\r\n\tthis.rotationMatrix.extractRotation( this.matrixWorld );\r\n\r\n\tthis.normal.set( 0, 0, 1 );\r\n\tthis.normal.applyMatrix4( this.rotationMatrix );\r\n\r\n\tvar view = this.mirrorWorldPosition.clone().sub( this.cameraWorldPosition );\r\n\tview.reflect( this.normal ).negate();\r\n\tview.add( this.mirrorWorldPosition );\r\n\r\n\tthis.rotationMatrix.extractRotation( this.camera.matrixWorld );\r\n\r\n\tthis.lookAtPosition.set( 0, 0, - 1 );\r\n\tthis.lookAtPosition.applyMatrix4( this.rotationMatrix );\r\n\tthis.lookAtPosition.add( this.cameraWorldPosition );\r\n\r\n\tvar target = this.mirrorWorldPosition.clone().sub( this.lookAtPosition );\r\n\ttarget.reflect( this.normal ).negate();\r\n\ttarget.add( this.mirrorWorldPosition );\r\n\r\n\tthis.up.set( 0, - 1, 0 );\r\n\tthis.up.applyMatrix4( this.rotationMatrix );\r\n\tthis.up.reflect( this.normal ).negate();\r\n\r\n\tthis.mirrorCamera.position.copy( view );\r\n\tthis.mirrorCamera.up = this.up;\r\n\tthis.mirrorCamera.lookAt( target );\r\n\r\n\tthis.mirrorCamera.updateProjectionMatrix();\r\n\tthis.mirrorCamera.updateMatrixWorld();\r\n\tthis.mirrorCamera.matrixWorldInverse.getInverse( this.mirrorCamera.matrixWorld );\r\n\r\n\t// Update the texture matrix\r\n\tthis.textureMatrix.set( 0.5, 0.0, 0.0, 0.5,\r\n\t\t\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t\t\t\t\t0.0, 0.0, 0.0, 1.0 );\r\n\tthis.textureMatrix.multiply( this.mirrorCamera.projectionMatrix );\r\n\tthis.textureMatrix.multiply( this.mirrorCamera.matrixWorldInverse );\r\n\r\n\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\r\n\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\r\n\tthis.mirrorPlane.setFromNormalAndCoplanarPoint( this.normal, this.mirrorWorldPosition );\r\n\tthis.mirrorPlane.applyMatrix4( this.mirrorCamera.matrixWorldInverse );\r\n\r\n\tthis.clipPlane.set( this.mirrorPlane.normal.x, this.mirrorPlane.normal.y, this.mirrorPlane.normal.z, this.mirrorPlane.constant );\r\n\r\n\tvar q = new THREE.Vector4();\r\n\tvar projectionMatrix = this.mirrorCamera.projectionMatrix;\r\n\r\n\tq.x = ( Math.sign( this.clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\r\n\tq.y = ( Math.sign( this.clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\r\n\tq.z = - 1.0;\r\n\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\r\n\r\n\t// Calculate the scaled plane vector\r\n\tvar c = new THREE.Vector4();\r\n\tc = this.clipPlane.multiplyScalar( 2.0 / this.clipPlane.dot( q ) );\r\n\r\n\t// Replacing the third row of the projection matrix\r\n\tprojectionMatrix.elements[ 2 ] = c.x;\r\n\tprojectionMatrix.elements[ 6 ] = c.y;\r\n\tprojectionMatrix.elements[ 10 ] = c.z + 1.0 - this.clipBias;\r\n\tprojectionMatrix.elements[ 14 ] = c.w;\r\n\r\n};\r\n\r\nTHREE.Mirror.prototype.render = function () {\r\n\r\n\tif ( this.matrixNeedsUpdate ) this.updateTextureMatrix();\r\n\r\n\tthis.matrixNeedsUpdate = true;\r\n\r\n\t// Render the mirrored view of the current scene into the target texture\r\n\tvar scene = this;\r\n\r\n\twhile ( scene.parent !== null ) {\r\n\r\n\t\tscene = scene.parent;\r\n\r\n\t}\r\n\r\n\tif ( scene !== undefined && scene instanceof THREE.Scene ) {\r\n\r\n\t\t// We can't render ourself to ourself\r\n\t\tvar visible = this.material.visible;\r\n\t\tthis.material.visible = false;\r\n\r\n\t\tthis.renderer.render( scene, this.mirrorCamera, this.renderTarget, true );\r\n\r\n\t\tthis.material.visible = visible;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Mirror.prototype.renderTemp = function () {\r\n\r\n\tif ( this.matrixNeedsUpdate ) this.updateTextureMatrix();\r\n\r\n\tthis.matrixNeedsUpdate = true;\r\n\r\n\t// Render the mirrored view of the current scene into the target texture\r\n\tvar scene = this;\r\n\r\n\twhile ( scene.parent !== null ) {\r\n\r\n\t\tscene = scene.parent;\r\n\r\n\t}\r\n\r\n\tif ( scene !== undefined && scene instanceof THREE.Scene ) {\r\n\r\n\t\tthis.renderer.render( scene, this.mirrorCamera, this.renderTarget2, true );\r\n\r\n\t}\r\n\r\n};\r\n"]}