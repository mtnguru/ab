{"version":3,"sources":["threejs/Half.js"],"names":["THREE","toHalf","floatView","Float32Array","int32View","Int32Array","buffer","val","x","bits","m","e"],"mappings":"AAIAA,MAAMC,OAAU,WACd,IAAIC,EAAY,IAAIC,aAAa,GAC7BC,EAAY,IAAIC,WAAWH,EAAUI,QAKzC,OAAO,SAAgBC,GAErBL,EAAU,GAAKK,EACf,IAAIC,EAAIJ,EAAU,GAEdK,EAAQD,GAAK,GAAM,MACnBE,EAAKF,GAAK,GAAM,KAChBG,EAAKH,GAAK,GAAM,IAIpB,OAAIG,EAAI,IACCF,EAILE,EAAI,KACNF,GAAQ,MAGRA,IAAe,KAALE,EAAY,EAAI,IAAW,QAAJH,GAK/BG,EAAI,KACND,GAAK,KAGLD,IAASC,GAAM,IAAMC,IAAQD,GAAM,IAAMC,EAAM,KAIjDF,GAAUE,EAAI,KAAQ,GAAOD,GAAK,EAGlCD,GAAY,EAAJC,IA3CG","file":"../../threejs/Half.js","sourcesContent":["/**\n * Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410\n */\n\nTHREE.toHalf = (function() {\n  var floatView = new Float32Array(1);\n  var int32View = new Int32Array(floatView.buffer);\n\n  /* This method is faster than the OpenEXR implementation (very often\n   * used, eg. in Ogre), with the additional benefit of rounding, inspired\n   * by James Tursa?s half-precision code. */\n  return function toHalf(val) {\n\n    floatView[0] = val;\n    var x = int32View[0];\n\n    var bits = (x >> 16) & 0x8000; /* Get the sign */\n    var m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */\n    var e = (x >> 23) & 0xff; /* Using int is faster here */\n\n    /* If zero, or denormal, or exponent underflows too much for a denormal\n     * half, return signed zero. */\n    if (e < 103) {\n      return bits;\n    }\n\n    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n    if (e > 142) {\n      bits |= 0x7c00;\n      /* If exponent was 0xff and one mantissa bit was set, it means NaN,\n           * not Inf, so make sure we set one mantissa bit too. */\n      bits |= ((e == 255) ? 0 : 1) && (x & 0x007fffff);\n      return bits;\n    }\n\n    /* If exponent underflows but not too much, return a denormal */\n    if (e < 113) {\n      m |= 0x0800;\n      /* Extra rounding may overflow and set mantissa to 0 and exponent\n       * to 1, which is OK. */\n      bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\n      return bits;\n    }\n\n    bits |= ((e - 112) << 10) | (m >> 1);\n    /* Extra rounding. An overflow will set mantissa to 0 and increment\n     * the exponent, which is OK. */\n    bits += m & 1;\n    return bits;\n  };\n}());\n"]}