{"version":3,"sources":["threejs/WaterShader.js"],"names":["THREE","ShaderLib","uniforms","UniformsUtils","merge","UniformsLib","normalSampler","value","mirrorSampler","alpha","time","distortionScale","noiseScale","textureMatrix","Matrix4","sunColor","Color","sunDirection","Vector3","eye","waterColor","vertexShader","join","fragmentShader","ShaderChunk","Water","renderer","camera","scene","options","optionalParameter","defaultValue","undefined","Object3D","call","this","name","id","matrixNeedsUpdate","width","textureWidth","height","textureHeight","clipBias","waterNormals","side","FrontSide","fog","mirrorPlane","Plane","normal","mirrorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","Vector4","PerspectiveCamera","console","log","mirrorCamera","clone","renderTarget","WebGLRenderTarget","renderTarget2","mirrorShader","mirrorUniforms","material","ShaderMaterial","transparent","texture","Math","isPowerOfTwo","generateMipmaps","minFilter","LinearFilter","updateTextureMatrix","render","prototype","Object","create","Mirror","constructor","sign","x","updateMatrixWorld","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","view","sub","reflect","negate","add","target","up","position","copy","lookAt","aspect","updateProjectionMatrix","matrixWorldInverse","getInverse","multiply","projectionMatrix","setFromNormalAndCoplanarPoint","y","z","constant","q","elements","w","c","multiplyScalar","dot","worldCoordinates"],"mappings":"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","file":"../../threejs/WaterShader.js","sourcesContent":["/**\n * @author jbouny / https://github.com/jbouny\n *\n * Work based on :\n * @author Slayvin / http://slayvin.net : Flat mirror for three.js\n * @author Stemkoski / http://www.adelphi.edu/~stemkoski : An implementation of water shader based on the flat mirror\n * @author Jonas Wagner / http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n */\n\nTHREE.ShaderLib[ 'water' ] = {\n\n\tuniforms: THREE.UniformsUtils.merge( [\n\t\tTHREE.UniformsLib[ \"fog\" ], {\n\t\t\t\"normalSampler\":    { value: null },\n\t\t\t\"mirrorSampler\":    { value: null },\n\t\t\t\"alpha\":            { value: 1.0 },\n\t\t\t\"time\":             { value: 0.0 },\n\t\t\t\"distortionScale\":  { value: 20.0 },\n\t\t\t\"noiseScale\":       { value: 1.0 },\n\t\t\t\"textureMatrix\" :   { value: new THREE.Matrix4() },\n\t\t\t\"sunColor\":         { value: new THREE.Color( 0x7F7F7F ) },\n\t\t\t\"sunDirection\":     { value: new THREE.Vector3( 0.70707, 0.70707, 0 ) },\n\t\t\t\"eye\":              { value: new THREE.Vector3() },\n\t\t\t\"waterColor\":       { value: new THREE.Color( 0x555555 ) }\n\t\t}\n\t] ),\n\n\tvertexShader: [\n\t\t'uniform mat4 textureMatrix;',\n\t\t'uniform float time;',\n\n\t\t'varying vec4 mirrorCoord;',\n\t\t'varying vec3 worldPosition;',\n\n\t\t'void main()',\n\t\t'{',\n\t\t'\tmirrorCoord = modelMatrix * vec4( position, 1.0 );',\n\t\t'\tworldPosition = mirrorCoord.xyz;',\n\t\t'\tmirrorCoord = textureMatrix * mirrorCoord;',\n\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\t\t'}'\n\t].join( '\\n' ),\n\n\tfragmentShader: [\n\t\t'precision highp float;',\n\n\t\t'uniform sampler2D mirrorSampler;',\n\t\t'uniform float alpha;',\n\t\t'uniform float time;',\n\t\t'uniform float distortionScale;',\n\t\t'uniform sampler2D normalSampler;',\n\t\t'uniform vec3 sunColor;',\n\t\t'uniform vec3 sunDirection;',\n\t\t'uniform vec3 eye;',\n\t\t'uniform vec3 waterColor;',\n\n\t\t'varying vec4 mirrorCoord;',\n\t\t'varying vec3 worldPosition;',\n\n\t\t'vec4 getNoise( vec2 uv )',\n\t\t'{',\n\t\t'\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);',\n\t\t'\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );',\n\t\t'\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );',\n\t\t'\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );',\n\t\t'\tvec4 noise = texture2D( normalSampler, uv0 ) +',\n\t\t'\t\ttexture2D( normalSampler, uv1 ) +',\n\t\t'\t\ttexture2D( normalSampler, uv2 ) +',\n\t\t'\t\ttexture2D( normalSampler, uv3 );',\n\t\t'\treturn noise * 0.5 - 1.0;',\n\t\t'}',\n\n\t\t'void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor )',\n\t\t'{',\n\t\t'\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );',\n\t\t'\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );',\n\t\t'\tspecularColor += pow( direction, shiny ) * sunColor * spec;',\n\t\t'\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;',\n\t\t'}',\n\n\t\tTHREE.ShaderChunk[ \"common\" ],\n\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\n\t\t'void main()',\n\t\t'{',\n\t\t'\tvec4 noise = getNoise( worldPosition.xz );',\n\t\t'\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );',\n\n\t\t'\tvec3 diffuseLight = vec3(0.0);',\n\t\t'\tvec3 specularLight = vec3(0.0);',\n\n\t\t'\tvec3 worldToEye = eye-worldPosition;',\n\t\t'\tvec3 eyeDirection = normalize( worldToEye );',\n\t\t'\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );',\n\n\t\t'\tfloat distance = length(worldToEye);',\n\n\t\t'\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;',\n\t\t'\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.z + distortion ) );',\n\n\t\t'\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );',\n\t\t'\tfloat rf0 = 0.3;',\n\t\t'\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );',\n\t\t'\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;',\n\t\t'\tvec3 albedo = mix( sunColor * diffuseLight * 0.3 + scatter, ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance );',\n\t\t'\tvec3 outgoingLight = albedo;',\n\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\t\t'\tgl_FragColor = vec4( outgoingLight, alpha );',\n\t\t'}'\n\t].join( '\\n' )\n\n};\n\nTHREE.Water = function ( renderer, camera, scene, options ) {\n\n\tTHREE.Object3D.call( this );\n\tthis.name = 'water_' + this.id;\n\n\tfunction optionalParameter ( value, defaultValue ) {\n\n\t\treturn value !== undefined ? value : defaultValue;\n\n\t}\n\n\toptions = options || {};\n\n\tthis.matrixNeedsUpdate = true;\n\n\tvar width = optionalParameter( options.textureWidth, 512 );\n\tvar height = optionalParameter( options.textureHeight, 512 );\n\tthis.clipBias = optionalParameter( options.clipBias, 0.0 );\n\tthis.alpha = optionalParameter( options.alpha, 1.0 );\n\tthis.time = optionalParameter( options.time, 0.0 );\n\tthis.normalSampler = optionalParameter( options.waterNormals, null );\n\tthis.sunDirection = optionalParameter( options.sunDirection, new THREE.Vector3( 0.70707, 0.70707, 0.0 ) );\n\tthis.sunColor = new THREE.Color( optionalParameter( options.sunColor, 0xffffff ) );\n\tthis.waterColor = new THREE.Color( optionalParameter( options.waterColor, 0x7F7F7F ) );\n\tthis.eye = optionalParameter( options.eye, new THREE.Vector3( 0, 0, 0 ) );\n\tthis.distortionScale = optionalParameter( options.distortionScale, 20.0 );\n\tthis.side = optionalParameter( options.side, THREE.FrontSide );\n\tthis.fog = optionalParameter( options.fog, false );\n\n\tthis.renderer = renderer;\n\tthis.scene = scene;\n\tthis.mirrorPlane = new THREE.Plane();\n\tthis.normal = new THREE.Vector3( 0, 0, 1 );\n\tthis.mirrorWorldPosition = new THREE.Vector3();\n\tthis.cameraWorldPosition = new THREE.Vector3();\n\tthis.rotationMatrix = new THREE.Matrix4();\n\tthis.lookAtPosition = new THREE.Vector3( 0, 0, - 1 );\n\tthis.clipPlane = new THREE.Vector4();\n\n\tif ( camera instanceof THREE.PerspectiveCamera ) {\n\n\t\tthis.camera = camera;\n\n\t} else {\n\n\t\tthis.camera = new THREE.PerspectiveCamera();\n\t\tconsole.log( this.name + ': camera is not a Perspective Camera!' );\n\n\t}\n\n\tthis.textureMatrix = new THREE.Matrix4();\n\n\tthis.mirrorCamera = this.camera.clone();\n\n\tthis.renderTarget = new THREE.WebGLRenderTarget( width, height );\n\tthis.renderTarget2 = new THREE.WebGLRenderTarget( width, height );\n\n\tvar mirrorShader = THREE.ShaderLib[ \"water\" ];\n\tvar mirrorUniforms = THREE.UniformsUtils.clone( mirrorShader.uniforms );\n\n\tthis.material = new THREE.ShaderMaterial( {\n\t\tfragmentShader: mirrorShader.fragmentShader,\n\t\tvertexShader: mirrorShader.vertexShader,\n\t\tuniforms: mirrorUniforms,\n\t\ttransparent: true,\n\t\tside: this.side,\n\t\tfog: this.fog\n\t} );\n\n\tthis.material.uniforms.mirrorSampler.value = this.renderTarget.texture;\n\tthis.material.uniforms.textureMatrix.value = this.textureMatrix;\n\tthis.material.uniforms.alpha.value = this.alpha;\n\tthis.material.uniforms.time.value = this.time;\n\tthis.material.uniforms.normalSampler.value = this.normalSampler;\n\tthis.material.uniforms.sunColor.value = this.sunColor;\n\tthis.material.uniforms.waterColor.value = this.waterColor;\n\tthis.material.uniforms.sunDirection.value = this.sunDirection;\n\tthis.material.uniforms.distortionScale.value = this.distortionScale;\n\n\tthis.material.uniforms.eye.value = this.eye;\n\n\tif ( ! THREE.Math.isPowerOfTwo( width ) || ! THREE.Math.isPowerOfTwo( height ) ) {\n\n\t\tthis.renderTarget.texture.generateMipmaps = false;\n\t\tthis.renderTarget.texture.minFilter = THREE.LinearFilter;\n\t\tthis.renderTarget2.texture.generateMipmaps = false;\n\t\tthis.renderTarget2.texture.minFilter = THREE.LinearFilter;\n\n\t}\n\n\tthis.updateTextureMatrix();\n\tthis.render();\n\n};\n\nTHREE.Water.prototype = Object.create( THREE.Mirror.prototype );\nTHREE.Water.prototype.constructor = THREE.Water;\n\n\nTHREE.Water.prototype.updateTextureMatrix = function () {\n\n\tfunction sign( x ) {\n\n\t\treturn x ? x < 0 ? - 1 : 1 : 0;\n\n\t}\n\n\tthis.updateMatrixWorld();\n\tthis.camera.updateMatrixWorld();\n\n\tthis.mirrorWorldPosition.setFromMatrixPosition( this.matrixWorld );\n\tthis.cameraWorldPosition.setFromMatrixPosition( this.camera.matrixWorld );\n\n\tthis.rotationMatrix.extractRotation( this.matrixWorld );\n\n\tthis.normal.set( 0, 0, 1 );\n\tthis.normal.applyMatrix4( this.rotationMatrix );\n\n\tvar view = this.mirrorWorldPosition.clone().sub( this.cameraWorldPosition );\n\tview.reflect( this.normal ).negate();\n\tview.add( this.mirrorWorldPosition );\n\n\tthis.rotationMatrix.extractRotation( this.camera.matrixWorld );\n\n\tthis.lookAtPosition.set( 0, 0, - 1 );\n\tthis.lookAtPosition.applyMatrix4( this.rotationMatrix );\n\tthis.lookAtPosition.add( this.cameraWorldPosition );\n\n\tvar target = this.mirrorWorldPosition.clone().sub( this.lookAtPosition );\n\ttarget.reflect( this.normal ).negate();\n\ttarget.add( this.mirrorWorldPosition );\n\n\tthis.up.set( 0, - 1, 0 );\n\tthis.up.applyMatrix4( this.rotationMatrix );\n\tthis.up.reflect( this.normal ).negate();\n\n\tthis.mirrorCamera.position.copy( view );\n\tthis.mirrorCamera.up = this.up;\n\tthis.mirrorCamera.lookAt( target );\n\tthis.mirrorCamera.aspect = this.camera.aspect;\n\n\tthis.mirrorCamera.updateProjectionMatrix();\n\tthis.mirrorCamera.updateMatrixWorld();\n\tthis.mirrorCamera.matrixWorldInverse.getInverse( this.mirrorCamera.matrixWorld );\n\n\t// Update the texture matrix\n\tthis.textureMatrix.set( 0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t\t\t0.0, 0.0, 0.0, 1.0 );\n\tthis.textureMatrix.multiply( this.mirrorCamera.projectionMatrix );\n\tthis.textureMatrix.multiply( this.mirrorCamera.matrixWorldInverse );\n\n\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\tthis.mirrorPlane.setFromNormalAndCoplanarPoint( this.normal, this.mirrorWorldPosition );\n\tthis.mirrorPlane.applyMatrix4( this.mirrorCamera.matrixWorldInverse );\n\n\tthis.clipPlane.set( this.mirrorPlane.normal.x, this.mirrorPlane.normal.y, this.mirrorPlane.normal.z, this.mirrorPlane.constant );\n\n\tvar q = new THREE.Vector4();\n\tvar projectionMatrix = this.mirrorCamera.projectionMatrix;\n\n\tq.x = ( sign( this.clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\tq.y = ( sign( this.clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\tq.z = - 1.0;\n\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t// Calculate the scaled plane vector\n\tvar c = new THREE.Vector4();\n\tc = this.clipPlane.multiplyScalar( 2.0 / this.clipPlane.dot( q ) );\n\n\t// Replacing the third row of the projection matrix\n\tprojectionMatrix.elements[ 2 ] = c.x;\n\tprojectionMatrix.elements[ 6 ] = c.y;\n\tprojectionMatrix.elements[ 10 ] = c.z + 1.0 - this.clipBias;\n\tprojectionMatrix.elements[ 14 ] = c.w;\n\n\tvar worldCoordinates = new THREE.Vector3();\n\tworldCoordinates.setFromMatrixPosition( this.camera.matrixWorld );\n\tthis.eye = worldCoordinates;\n\tthis.material.uniforms.eye.value = this.eye;\n\n};\n"]}