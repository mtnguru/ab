var RollerCoasterGeometry=function(e,t){THREE.BufferGeometry.call(this);var r=[],o=[],a=[],n=[1,1,1],p=[1,1,0],E=new THREE.Vector3(0,1,0),y=new THREE.Vector3,u=new THREE.Vector3,s=new THREE.Quaternion,c=new THREE.Quaternion;c.setFromAxisAngle(E,Math.PI/2);var i=new THREE.Vector3,h=new THREE.Vector3;h.copy(e.getPointAt(0));for(var l=[new THREE.Vector3(-2.25,0,0),new THREE.Vector3(0,-.5,0),new THREE.Vector3(0,-1.75,0),new THREE.Vector3(0,-.5,0),new THREE.Vector3(2.25,0,0),new THREE.Vector3(0,-1.75,0)],R=2*Math.PI,d=5,T=[],w=0;w<d;w++){g=w/d*R;T.push(new THREE.Vector3(.6*Math.sin(g),.6*Math.cos(g),0))}for(var d=6,H=[],w=0;w<d;w++){g=w/d*R;H.push(new THREE.Vector3(.25*Math.sin(g),.25*Math.cos(g),0))}for(var f=new THREE.Vector3,V=new THREE.Vector3,z=new THREE.Vector3,m=new THREE.Vector3,A=new THREE.Vector3,x=new THREE.Vector3,Q=new THREE.Vector3,M=new THREE.Vector3,v=new THREE.Vector3,b=new THREE.Vector3,G=function(e,t,n){for(var p=0,E=e.length;p<E;p++){var y=e[p],u=e[(p+1)%E];z.copy(y).add(t),z.applyQuaternion(s),z.add(i),m.copy(u).add(t),m.applyQuaternion(s),m.add(i),A.copy(u).add(t),A.applyQuaternion(c),A.add(h),x.copy(y).add(t),x.applyQuaternion(c),x.add(h),r.push(z.x,z.y,z.z),r.push(m.x,m.y,m.z),r.push(x.x,x.y,x.z),r.push(m.x,m.y,m.z),r.push(A.x,A.y,A.z),r.push(x.x,x.y,x.z),Q.copy(y),Q.applyQuaternion(s),Q.normalize(),M.copy(u),M.applyQuaternion(s),M.normalize(),v.copy(u),v.applyQuaternion(c),v.normalize(),b.copy(y),b.applyQuaternion(c),b.normalize(),o.push(Q.x,Q.y,Q.z),o.push(M.x,M.y,M.z),o.push(b.x,b.y,b.z),o.push(M.x,M.y,M.z),o.push(v.x,v.y,v.z),o.push(b.x,b.y,b.z),a.push(n[0],n[1],n[2]),a.push(n[0],n[1],n[2]),a.push(n[0],n[1],n[2]),a.push(n[0],n[1],n[2]),a.push(n[0],n[1],n[2]),a.push(n[0],n[1],n[2])}},B=new THREE.Vector3,w=1;w<=t;w++){i.copy(e.getPointAt(w/t)),E.set(0,1,0),y.subVectors(i,h).normalize(),u.crossVectors(E,y).normalize(),E.crossVectors(y,u);var g=Math.atan2(y.x,y.z);s.setFromAxisAngle(E,g),w%2==0&&function(e,t){V.set(0,0,-1).applyQuaternion(s);for(n=0;n<e.length;n++)f.copy(e[n]),f.applyQuaternion(s),f.add(i),r.push(f.x,f.y,f.z),o.push(V.x,V.y,V.z),a.push(t[0],t[1],t[2]);V.set(0,0,1).applyQuaternion(s);for(var n=e.length-1;n>=0;n--)f.copy(e[n]),f.applyQuaternion(s),f.add(i),r.push(f.x,f.y,f.z),o.push(V.x,V.y,V.z),a.push(t[0],t[1],t[2])}(l,p),G(T,B.set(0,-1.25,0),p),G(H,B.set(2,0,0),n),G(H,B.set(-2,0,0),n),h.copy(i),c.copy(s)}this.addAttribute("position",new THREE.BufferAttribute(new Float32Array(r),3)),this.addAttribute("normal",new THREE.BufferAttribute(new Float32Array(o),3)),this.addAttribute("color",new THREE.BufferAttribute(new Float32Array(a),3))};RollerCoasterGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);var RollerCoasterLiftersGeometry=function(e,t){THREE.BufferGeometry.call(this);for(var r=[],o=[],a=new THREE.Quaternion,n=new THREE.Vector3(0,1,0),p=new THREE.Vector3,E=new THREE.Vector3,y=[new THREE.Vector3(0,.5,-.5),new THREE.Vector3(0,.5,.5),new THREE.Vector3(0,-.5,0)],u=[new THREE.Vector3(-.5,0,.5),new THREE.Vector3(-.5,0,-.5),new THREE.Vector3(.5,0,0)],s=[new THREE.Vector3(.5,0,-.5),new THREE.Vector3(.5,0,.5),new THREE.Vector3(-.5,0,0)],c=new THREE.Vector3,i=new THREE.Vector3,h=new THREE.Vector3,l=new THREE.Vector3,R=new THREE.Vector3,d=new THREE.Vector3,T=new THREE.Vector3,w=new THREE.Vector3,H=function(e,t,n){for(var p=0,E=e.length;p<E;p++){var y=e[p],u=e[(p+1)%E];c.copy(y),c.applyQuaternion(a),c.add(t),i.copy(u),i.applyQuaternion(a),i.add(t),h.copy(u),h.applyQuaternion(a),h.add(n),l.copy(y),l.applyQuaternion(a),l.add(n),r.push(c.x,c.y,c.z),r.push(i.x,i.y,i.z),r.push(l.x,l.y,l.z),r.push(i.x,i.y,i.z),r.push(h.x,h.y,h.z),r.push(l.x,l.y,l.z),R.copy(y),R.applyQuaternion(a),R.normalize(),d.copy(u),d.applyQuaternion(a),d.normalize(),T.copy(u),T.applyQuaternion(a),T.normalize(),w.copy(y),w.applyQuaternion(a),w.normalize(),o.push(R.x,R.y,R.z),o.push(d.x,d.y,d.z),o.push(w.x,w.y,w.z),o.push(d.x,d.y,d.z),o.push(T.x,T.y,T.z),o.push(w.x,w.y,w.z)}},f=new THREE.Vector3,V=new THREE.Vector3,z=1;z<=t;z++){p.copy(e.getPointAt(z/t)),E.copy(e.getTangentAt(z/t));var m=Math.atan2(E.x,E.z);a.setFromAxisAngle(n,m),p.y>100?(f.set(-7.5,-3.5,0),f.applyQuaternion(a),f.add(p),V.set(7.5,-3.5,0),V.applyQuaternion(a),V.add(p),H(y,f,V),f.set(-7,-3,0),f.applyQuaternion(a),f.add(p),V.set(-7,-p.y,0),V.applyQuaternion(a),V.add(p),H(u,f,V),f.set(7,-3,0),f.applyQuaternion(a),f.add(p),V.set(7,-p.y,0),V.applyQuaternion(a),V.add(p),H(s,f,V)):(f.set(0,-2,0),f.applyQuaternion(a),f.add(p),V.set(0,-p.y,0),V.applyQuaternion(a),V.add(p),H(s,f,V))}this.addAttribute("position",new THREE.BufferAttribute(new Float32Array(r),3)),this.addAttribute("normal",new THREE.BufferAttribute(new Float32Array(o),3))};RollerCoasterLiftersGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);var RollerCoasterShadowGeometry=function(e,t){THREE.BufferGeometry.call(this);var r=[],o=new THREE.Vector3(0,1,0),a=new THREE.Vector3,n=new THREE.Quaternion,p=new THREE.Quaternion;p.setFromAxisAngle(o,Math.PI/2);var E=new THREE.Vector3,y=new THREE.Vector3;y.copy(e.getPointAt(0)),y.y=0;for(var u=new THREE.Vector3,s=new THREE.Vector3,c=new THREE.Vector3,i=new THREE.Vector3,h=1;h<=t;h++){E.copy(e.getPointAt(h/t)),E.y=0,a.subVectors(E,y);var l=Math.atan2(a.x,a.z);n.setFromAxisAngle(o,l),u.set(-3,0,0),u.applyQuaternion(n),u.add(E),s.set(3,0,0),s.applyQuaternion(n),s.add(E),c.set(3,0,0),c.applyQuaternion(p),c.add(y),i.set(-3,0,0),i.applyQuaternion(p),i.add(y),r.push(u.x,u.y,u.z),r.push(s.x,s.y,s.z),r.push(i.x,i.y,i.z),r.push(s.x,s.y,s.z),r.push(c.x,c.y,c.z),r.push(i.x,i.y,i.z),y.copy(E),p.copy(n)}this.addAttribute("position",new THREE.BufferAttribute(new Float32Array(r),3))};RollerCoasterShadowGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);var SkyGeometry=function(){THREE.BufferGeometry.call(this);for(var e=[],t=0;t<100;t++){var r=8e3*Math.random()-4e3,o=500*Math.random()+500,a=8e3*Math.random()-4e3,n=400*Math.random()+200;e.push(r-n,o,a-n),e.push(r+n,o,a-n),e.push(r-n,o,a+n),e.push(r+n,o,a-n),e.push(r+n,o,a+n),e.push(r-n,o,a+n)}this.addAttribute("position",new THREE.BufferAttribute(new Float32Array(e),3))};SkyGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);var TreesGeometry=function(e){THREE.BufferGeometry.call(this);var t=[],r=[],o=new THREE.Raycaster;o.ray.direction.set(0,-1,0);for(var a=0;a<2e3;a++){var n=5e3*Math.random()-2500,p=5e3*Math.random()-2500;o.ray.origin.set(n,500,p);var E=o.intersectObject(e);if(0!==E.length){var y=E[0].point.y,u=50*Math.random()+5,s=Math.random()*Math.PI*2;t.push(n+10*Math.sin(s),y,p+10*Math.cos(s)),t.push(n,y+u,p),t.push(n+10*Math.sin(s+Math.PI),y,p+10*Math.cos(s+Math.PI)),s+=Math.PI/2,t.push(n+10*Math.sin(s),y,p+10*Math.cos(s)),t.push(n,y+u,p),t.push(n+10*Math.sin(s+Math.PI),y,p+10*Math.cos(s+Math.PI));for(var c=.1*Math.random(),i=0;i<6;i++)r.push(.2+c,.4+c,0)}}this.addAttribute("position",new THREE.BufferAttribute(new Float32Array(t),3)),this.addAttribute("color",new THREE.BufferAttribute(new Float32Array(r),3))};TreesGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);
//# sourceMappingURL=../maps/threejs/RollerCoaster.js.map
