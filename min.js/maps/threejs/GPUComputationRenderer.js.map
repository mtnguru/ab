{"version":3,"sources":["threejs/GPUComputationRenderer.js"],"names":["GPUComputationRenderer","sizeX","sizeY","renderer","addResolutionDefine","materialShader","defines","resolution","toFixed","createShaderMaterial","computeFragmentShader","uniforms","material","THREE","ShaderMaterial","vertexShader","fragmentShader","this","variables","currentTextureIndex","scene","Scene","camera","Camera","position","z","passThruUniforms","texture","value","passThruShader","mesh","Mesh","PlaneBufferGeometry","add","addVariable","variableName","initialValueTexture","variable","name","dependencies","renderTargets","wrapS","wrapT","minFilter","NearestFilter","magFilter","push","setVariableDependencies","init","extensions","get","capabilities","maxVertexTextures","i","length","createRenderTarget","renderTexture","d","depVar","found","j","compute","nextTextureIndex","il","dl","doRenderTarget","getCurrentRenderTarget","getAlternateRenderTarget","sizeXTexture","sizeYTexture","ClampToEdgeWrapping","WebGLRenderTarget","format","RGBAFormat","type","FloatType","stencilBuffer","createTexture","a","Float32Array","DataTexture","needsUpdate","input","output","render"],"mappings":"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","file":"../../threejs/GPUComputationRenderer.js","sourcesContent":["/**\n * @author yomboprime https://github.com/yomboprime\n *\n * GPUComputationRenderer, based on SimulationRenderer by zz85\n *\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\n * for each compute element (texel)\n *\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\n *\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\n * as inputs to render the textures of the next frame.\n *\n * The render targets of the variables can be used as input textures for your visualization shaders.\n *\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\n *\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\n *\n * -------------\n *\n * Basic use:\n *\n * // Initialization...\n *\n * // Create computation renderer\n * var gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\n *\n * // Create initial state float textures\n * var pos0 = gpuCompute.createTexture();\n * var vel0 = gpuCompute.createTexture();\n * // and fill in here the texture data...\n *\n * // Add texture variables\n * var velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, pos0 );\n * var posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, vel0 );\n *\n * // Add variable dependencies\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\n *\n * // Add custom uniforms\n * velVar.material.uniforms.time = { value: 0.0 };\n *\n * // Check for completeness\n * var error = gpuCompute.init();\n * if ( error !== null ) {\n *\t\tconsole.error( error );\n  * }\n *\n *\n * // In each frame...\n *\n * // Compute!\n * gpuCompute.compute();\n *\n * // Update texture uniforms in your visualization materials with the gpu renderer output\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\n *\n * // Do your rendering\n * renderer.render( myScene, myCamera );\n *\n * -------------\n *\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\n * Note that the shaders can have multiple input textures.\n *\n * var myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\n * var myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\n *\n * var inputTexture = gpuCompute.createTexture();\n *\n * // Fill in here inputTexture...\n *\n * myFilter1.uniforms.theTexture.value = inputTexture;\n *\n * var myRenderTarget = gpuCompute.createRenderTarget();\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\n *\n * var outputRenderTarget = gpuCompute.createRenderTarget();\n *\n * // Now use the output texture where you want:\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\n *\n * // And compute each frame, before rendering to screen:\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\n * \n *\n *\n * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {WebGLRenderer} renderer The renderer\n  */\n\nfunction GPUComputationRenderer( sizeX, sizeY, renderer ) {\n\n\tthis.variables = [];\n\n\tthis.currentTextureIndex = 0;\n\n\tvar scene = new THREE.Scene();\n\n\tvar camera = new THREE.Camera();\n\tcamera.position.z = 1;\n\n\tvar passThruUniforms = {\n\t\ttexture: { value: null }\n\t};\n\n\tvar passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );\n\n\tvar mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), passThruShader );\n\tscene.add( mesh );\n\n\n\tthis.addVariable = function( variableName, computeFragmentShader, initialValueTexture ) {\n\n\t\tvar material = this.createShaderMaterial( computeFragmentShader );\n\n\t\tvar variable = {\n\t\t\tname: variableName,\n\t\t\tinitialValueTexture: initialValueTexture,\n\t\t\tmaterial: material,\n\t\t\tdependencies: null,\n\t\t\trenderTargets: [],\n\t\t\twrapS: null,\n\t\t\twrapT: null,\n\t\t\tminFilter: THREE.NearestFilter,\n\t\t\tmagFilter: THREE.NearestFilter\n\t\t};\n\n\t\tthis.variables.push( variable );\n\n\t\treturn variable;\n\t\t\n\t};\n\n\tthis.setVariableDependencies = function( variable, dependencies ) {\n\n\t\tvariable.dependencies = dependencies;\n\n\t};\n\n\tthis.init = function() {\n\n\t\tif ( ! renderer.extensions.get( \"OES_texture_float\" ) ) {\n\n\t\t\treturn \"No OES_texture_float support for float textures.\";\n\n\t\t}\n\n\t\tif ( renderer.capabilities.maxVertexTextures === 0 ) {\n\n\t\t\treturn \"No support for vertex shader textures.\";\n\n\t\t}\n\n\t\tfor ( var i = 0; i < this.variables.length; i++ ) {\n\n\t\t\tvar variable = this.variables[ i ];\n\n\t\t\t// Creates rendertargets and initialize them with input texture\n\t\t\tvariable.renderTargets[ 0 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\tvariable.renderTargets[ 1 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );\n\n\t\t\t// Adds dependencies uniforms to the ShaderMaterial\n\t\t\tvar material = variable.material;\n\t\t\tvar uniforms = material.uniforms;\n\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\tfor ( var d = 0; d < variable.dependencies.length; d++ ) {\n\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\n\n\t\t\t\t\tif ( depVar.name !== variable.name ) {\n\n\t\t\t\t\t\t// Checks if variable exists\n\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\tfor ( var j = 0; j < this.variables.length; j++ ) {\n\n\t\t\t\t\t\t\tif ( depVar.name === this.variables[ j ].name ) {\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( ! found ) {\n\t\t\t\t\t\t\treturn \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tuniforms[ depVar.name ] = { value: null };\n\n\t\t\t\t\tmaterial.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.currentTextureIndex = 0;\n\n\t\treturn null;\n\n\t};\n\n\tthis.compute = function() {\n\n\t\tvar currentTextureIndex = this.currentTextureIndex;\n\t\tvar nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n\n\t\tfor ( var i = 0, il = this.variables.length; i < il; i++ ) {\n\n\t\t\tvar variable = this.variables[ i ];\n\n\t\t\t// Sets texture dependencies uniforms\n\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\tvar uniforms = variable.material.uniforms;\n\t\t\t\tfor ( var d = 0, dl = variable.dependencies.length; d < dl; d++ ) {\n\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\n\n\t\t\t\t\tuniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Performs the computation for this variable\n\t\t\tthis.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );\n\n\t\t}\n\n\t\tthis.currentTextureIndex = nextTextureIndex;\n\t};\n\n\tthis.getCurrentRenderTarget = function( variable ) {\n\n\t\treturn variable.renderTargets[ this.currentTextureIndex ];\n\n\t};\n\n\tthis.getAlternateRenderTarget = function( variable ) {\n\n\t\treturn variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];\n\n\t};\n\n\tfunction addResolutionDefine( materialShader ) {\n\n\t\tmaterialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + \" )\";\n\n\t};\n\tthis.addResolutionDefine = addResolutionDefine;\n\n\n\t// The following functions can be used to compute things manually\n\n\tfunction createShaderMaterial( computeFragmentShader, uniforms ) {\n\n\t\tuniforms = uniforms || {};\n\n\t\tvar material = new THREE.ShaderMaterial( {\n\t\t\tuniforms: uniforms,\n\t\t\tvertexShader: getPassThroughVertexShader(),\n\t\t\tfragmentShader: computeFragmentShader\n\t\t} );\n\n\t\taddResolutionDefine( material );\n\n\t\treturn material;\n\t};\n\tthis.createShaderMaterial = createShaderMaterial;\n\n\tthis.createRenderTarget = function( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {\n\n\t\tsizeXTexture = sizeXTexture || sizeX;\n\t\tsizeYTexture = sizeYTexture || sizeY;\n\n\t\twrapS = wrapS || THREE.ClampToEdgeWrapping;\n\t\twrapT = wrapT || THREE.ClampToEdgeWrapping;\n\n\t\tminFilter = minFilter || THREE.NearestFilter;\n\t\tmagFilter = magFilter || THREE.NearestFilter;\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget( sizeXTexture, sizeYTexture, {\n\t\t\twrapS: wrapS,\n\t\t\twrapT: wrapT,\n\t\t\tminFilter: minFilter,\n\t\t\tmagFilter: magFilter,\n\t\t\tformat: THREE.RGBAFormat,\n\t\t\ttype: THREE.FloatType,\n\t\t\tstencilBuffer: false\n\t\t} );\n\n\t\treturn renderTarget;\n\n\t};\n\n    this.createTexture = function( sizeXTexture, sizeYTexture ) {\n\n\t\tsizeXTexture = sizeXTexture || sizeX;\n\t\tsizeYTexture = sizeYTexture || sizeY;\n\n\t\tvar a = new Float32Array( sizeXTexture * sizeYTexture * 4 );\n\t\tvar texture = new THREE.DataTexture( a, sizeX, sizeY, THREE.RGBAFormat, THREE.FloatType );\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t};\n\n\n\tthis.renderTexture = function( input, output ) {\n\n\t\t// Takes a texture, and render out in rendertarget\n\t\t// input = Texture\n\t\t// output = RenderTarget\n\n\t\tpassThruUniforms.texture.value = input;\n\n\t\tthis.doRenderTarget( passThruShader, output);\n\n\t\tpassThruUniforms.texture.value = null;\n\n\t};\n\n\tthis.doRenderTarget = function( material, output ) {\n\n\t\tmesh.material = material;\n\t\trenderer.render( scene, camera, output );\n\t\tmesh.material = passThruShader;\n\n\t};\n\n\t// Shaders\n\n\tfunction getPassThroughVertexShader() {\n\n\t\treturn\t\"void main()\t{\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"\tgl_Position = vec4( position, 1.0 );\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"}\\n\";\n\n\t}\n\n\tfunction getPassThroughFragmentShader() {\n\n\t\treturn\t\"uniform sampler2D texture;\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"void main() {\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"\tgl_FragColor = texture2D( texture, uv );\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"}\\n\";\n\n\t}\n\n}"]}