{"version":3,"sources":["threejs/Octree.js"],"names":["THREE","isNumber","n","isNaN","isFinite","isArray","target","Object","prototype","toString","call","toArray","indexOfValue","array","value","i","il","length","indexOfPropertyWithValue","property","Octree","parameters","tree","this","nodeCount","INDEX_INSIDE_CROSS","INDEX_OUTSIDE_OFFSET","INDEX_OUTSIDE_POS_X","INDEX_OUTSIDE_NEG_X","INDEX_OUTSIDE_POS_Y","INDEX_OUTSIDE_NEG_Y","INDEX_OUTSIDE_POS_Z","INDEX_OUTSIDE_NEG_Z","INDEX_OUTSIDE_MAP","index","count","x","y","z","FLAG_POS_X","FLAG_NEG_X","FLAG_POS_Y","FLAG_NEG_Y","FLAG_POS_Z","FLAG_NEG_Z","utilVec31Search","Vector3","utilVec32Search","scene","visualGeometry","BoxGeometry","visualMaterial","MeshBasicMaterial","color","wireframe","wireframeLinewidth","objects","objectsMap","objectsData","objectsDeferred","depthMax","Infinity","objectsThreshold","overlapPct","undeferred","root","OctreeNode","update","deferred","addDeferred","object","options","add","updateObject","push","l","faces","useFaces","vertices","useVertices","OctreeObjectData","uuid","Math","generateUUID","geometry","addObjectData","part","objectData","addObject","remove","objectsDataRemoved","undefined","splice","removeObject","extend","octree","rebuild","node","indexOctantLast","objectsUpdate","positionLast","equals","position","indexOctant","getOctantIndex","parent","parentUpdate","parentCascade","matrixWorldNeedsUpdate","updateMatrixWorld","search","radius","organizeByObject","direction","results","resultData","resultsObjectsIndices","resultObjectIndex","directionPct","concat","Number","MAX_VALUE","copy","normalize","set","divide","nodesIndices","nodesByIndex","setRoot","updateProperties","getDepthEnd","getNodeCountEnd","getObjectCountEnd","toConsole","Face3","face3","utilVec31FaceBounds","Object3D","clone","getFace3BoundingRadius","centroid","applyMatrix4","matrixWorld","material","size","boundingSphere","computeBoundingSphere","center","boundRadius","setFromMatrixPosition","max","scale","face","va","a","vb","b","vc","c","centroidToVert","addVectors","divideScalar","subVectors","utilVec31Branch","utilVec31Expand","utilVec31Ray","id","depth","reset","setParent","overlap","radiusOverlap","left","right","bottom","top","back","front","visual","Mesh","cascade","removeVisual","addNode","removeNode","branch","checkGrow","addObjectWithoutCheck","nodesRemovedFrom","removeData","removeObjectRecursive","searchComplete","shrink","objectRemoved","grow","objectsExpand","objectsExpandOctants","objectsSplit","objectsSplitOctants","objectsRemaining","split","expand","checkMerge","octants","radiusOffset","offset","flagsOutside","indexOctantInverse","indexOutsideCounts","infoIndexOutside1","infoIndexOutside2","infoIndexOutside3","indexOutsideBitwise1","indexOutsideBitwise2","infoPotential1","infoPotential2","infoPotential3","indexPotentialBitwise1","indexPotentialBitwise2","octantX","octantY","octantZ","radiusParent","iom","slice","sort","getOctantIndexFromPosition","checkContract","nodeMerge","nodeParent","merge","nodes","getObjectsEnd","nodeObjectsCount","nodeHeaviest","nodeHeaviestObjectsCount","outsideHeaviestObjectsCount","contract","nodeRoot","positionObj","radiusObj","deltaX","deltaY","deltaZ","distX","distY","distZ","abs","intersectRay","intersectSphere","distance","px","py","pz","pow","origin","tmin","t1","t2","t3","t4","t5","t6","tmax","min","getNodeCountRecursive","getObjectCountStart","space","console","log","Raycaster","intersectOctreeObject","recursive","intersects","octreeObject","facesAll","facesSearch","intersectObject","intersectOctreeObjects"],"mappings":"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","file":"../../threejs/Octree.js","sourcesContent":["/*!\n *\n * threeoctree.js (r60) / https://github.com/collinhover/threeoctree\n * (sparse) dynamic 3D spatial representation structure for fast searches.\n *\n * @author Collin Hover / http://collinhover.com/\n * based on Dynamic Octree by Piko3D @ http://www.piko3d.com/ and Octree by Marek Pawlowski @ pawlowski.it\n *\n */\n ( function ( THREE ) {\n\n\t\"use strict\";\n\t\n\t/*===================================================\n\n\tutility\n\n\t=====================================================*/\n\t\n\tfunction isNumber ( n ) {\n\n\t\treturn ! isNaN( n ) && isFinite( n );\n\n\t}\n\t\n\tfunction isArray ( target ) {\n\n\t\treturn Object.prototype.toString.call( target ) === '[object Array]';\n\n\t}\n\t\n\tfunction toArray ( target ) {\n\n\t\treturn target ? ( isArray ( target ) !== true ? [ target ] : target ) : [];\n\n\t}\n\t\n\tfunction indexOfValue( array, value ) {\n\t\t\n\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\t\t\t\n\t\t\tif ( array[ i ] === value ) {\n\t\t\t\t\n\t\t\t\treturn i;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\treturn - 1;\n\t\t\n\t}\n\t\n\tfunction indexOfPropertyWithValue( array, property, value ) {\n\t\t\n\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\t\t\t\n\t\t\tif ( array[ i ][ property ] === value ) {\n\t\t\t\t\n\t\t\t\treturn i;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\treturn - 1;\n\t\t\n\t}\n\n\t/*===================================================\n\n\toctree\n\n\t=====================================================*/\n\n\tTHREE.Octree = function ( parameters ) {\n\t\t\n\t\t// handle parameters\n\t\t\n\t\tparameters = parameters || {};\n\t\t\n\t\tparameters.tree = this;\n\t\t\n\t\t// static properties ( modification is not recommended )\n\t\t\n\t\tthis.nodeCount = 0;\n\t\t\n\t\tthis.INDEX_INSIDE_CROSS = - 1;\n\t\tthis.INDEX_OUTSIDE_OFFSET = 2;\n\t\t\n\t\tthis.INDEX_OUTSIDE_POS_X = isNumber( parameters.INDEX_OUTSIDE_POS_X ) ? parameters.INDEX_OUTSIDE_POS_X : 0;\n\t\tthis.INDEX_OUTSIDE_NEG_X = isNumber( parameters.INDEX_OUTSIDE_NEG_X ) ? parameters.INDEX_OUTSIDE_NEG_X : 1;\n\t\tthis.INDEX_OUTSIDE_POS_Y = isNumber( parameters.INDEX_OUTSIDE_POS_Y ) ? parameters.INDEX_OUTSIDE_POS_Y : 2;\n\t\tthis.INDEX_OUTSIDE_NEG_Y = isNumber( parameters.INDEX_OUTSIDE_NEG_Y ) ? parameters.INDEX_OUTSIDE_NEG_Y : 3;\n\t\tthis.INDEX_OUTSIDE_POS_Z = isNumber( parameters.INDEX_OUTSIDE_POS_Z ) ? parameters.INDEX_OUTSIDE_POS_Z : 4;\n\t\tthis.INDEX_OUTSIDE_NEG_Z = isNumber( parameters.INDEX_OUTSIDE_NEG_Z ) ? parameters.INDEX_OUTSIDE_NEG_Z : 5;\n\t\t\n\t\tthis.INDEX_OUTSIDE_MAP = [];\n\t\tthis.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_POS_X ] = { index: this.INDEX_OUTSIDE_POS_X, count: 0, x: 1, y: 0, z: 0 };\n\t\tthis.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_NEG_X ] = { index: this.INDEX_OUTSIDE_NEG_X, count: 0, x: - 1, y: 0, z: 0 };\n\t\tthis.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_POS_Y ] = { index: this.INDEX_OUTSIDE_POS_Y, count: 0, x: 0, y: 1, z: 0 };\n\t\tthis.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_NEG_Y ] = { index: this.INDEX_OUTSIDE_NEG_Y, count: 0, x: 0, y: - 1, z: 0 };\n\t\tthis.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_POS_Z ] = { index: this.INDEX_OUTSIDE_POS_Z, count: 0, x: 0, y: 0, z: 1 };\n\t\tthis.INDEX_OUTSIDE_MAP[ this.INDEX_OUTSIDE_NEG_Z ] = { index: this.INDEX_OUTSIDE_NEG_Z, count: 0, x: 0, y: 0, z: - 1 };\n\t\t\n\t\tthis.FLAG_POS_X = 1 << ( this.INDEX_OUTSIDE_POS_X + 1 );\n\t\tthis.FLAG_NEG_X = 1 << ( this.INDEX_OUTSIDE_NEG_X + 1 );\n\t\tthis.FLAG_POS_Y = 1 << ( this.INDEX_OUTSIDE_POS_Y + 1 );\n\t\tthis.FLAG_NEG_Y = 1 << ( this.INDEX_OUTSIDE_NEG_Y + 1 );\n\t\tthis.FLAG_POS_Z = 1 << ( this.INDEX_OUTSIDE_POS_Z + 1 );\n\t\tthis.FLAG_NEG_Z = 1 << ( this.INDEX_OUTSIDE_NEG_Z + 1 );\n\t\t\n\t\tthis.utilVec31Search = new THREE.Vector3();\n\t\tthis.utilVec32Search = new THREE.Vector3();\n\t\t\n\t\t// pass scene to see octree structure\n\t\t\n\t\tthis.scene = parameters.scene;\n\t\t\n\t\tif ( this.scene ) {\n\t\t\t\n\t\t\tthis.visualGeometry = new THREE.BoxGeometry( 1, 1, 1 );\n\t\t\tthis.visualMaterial = new THREE.MeshBasicMaterial( { color: 0xFF0066, wireframe: true, wireframeLinewidth: 1 } );\n\t\t\t\n\t\t}\n\t\t\n\t\t// properties\n\t\t\n\t\tthis.objects = [];\n\t\tthis.objectsMap = {};\n\t\tthis.objectsData = [];\n\t\tthis.objectsDeferred = [];\n\t\t\n\t\tthis.depthMax = isNumber( parameters.depthMax ) ? parameters.depthMax : Infinity;\n\t\tthis.objectsThreshold = isNumber( parameters.objectsThreshold ) ? parameters.objectsThreshold : 8;\n\t\tthis.overlapPct = isNumber( parameters.overlapPct ) ? parameters.overlapPct : 0.15;\n\t\tthis.undeferred = parameters.undeferred || false;\n\t\t\n\t\tthis.root = parameters.root instanceof THREE.OctreeNode ? parameters.root : new THREE.OctreeNode( parameters );\n\t\t\n\t};\n\n\tTHREE.Octree.prototype = {\n\t\t\n\t\tupdate: function () {\n\t\t\t\n\t\t\t// add any deferred objects that were waiting for render cycle\n\t\t\t\n\t\t\tif ( this.objectsDeferred.length > 0 ) {\n\t\t\t\t\n\t\t\t\tfor ( var i = 0, il = this.objectsDeferred.length; i < il; i ++ ) {\n\t\t\t\t\t\n\t\t\t\t\tvar deferred = this.objectsDeferred[ i ];\n\t\t\t\t\t\n\t\t\t\t\tthis.addDeferred( deferred.object, deferred.options );\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.objectsDeferred.length = 0;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\tadd: function ( object, options ) {\n\t\t\t\n\t\t\t// add immediately\n\t\t\t\n\t\t\tif ( this.undeferred ) {\n\t\t\t\t\n\t\t\t\tthis.updateObject( object );\n\t\t\t\t\n\t\t\t\tthis.addDeferred( object, options );\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// defer add until update called\n\t\t\t\t\n\t\t\t\tthis.objectsDeferred.push( { object: object, options: options } );\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\taddDeferred: function ( object, options ) {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tgeometry,\n\t\t\t\tfaces,\n\t\t\t\tuseFaces,\n\t\t\t\tvertices,\n\t\t\t\tuseVertices,\n\t\t\t\tobjectData;\n\t\t\t\n\t\t\t// ensure object is not object data\n\t\t\t\n\t\t\tif ( object instanceof THREE.OctreeObjectData ) {\n\t\t\t\t\n\t\t\t\tobject = object.object;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// check uuid to avoid duplicates\n\t\t\t\n\t\t\tif ( ! object.uuid ) {\n\t\t\t\t\n\t\t\t\tobject.uuid = THREE.Math.generateUUID();\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif ( ! this.objectsMap[ object.uuid ] ) {\n\t\t\t\t\n\t\t\t\t// store\n\t\t\t\t\n\t\t\t\tthis.objects.push( object );\n\t\t\t\tthis.objectsMap[ object.uuid ] = object;\n\t\t\t\t\n\t\t\t\t// check options\n\t\t\t\t\n\t\t\t\tif ( options ) {\n\t\t\t\t\t\n\t\t\t\t\tuseFaces = options.useFaces;\n\t\t\t\t\tuseVertices = options.useVertices;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( useVertices === true ) {\n\t\t\t\t\t\n\t\t\t\t\tgeometry = object.geometry;\n\t\t\t\t\tvertices = geometry.vertices;\n\t\t\t\t\t\n\t\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.addObjectData( object, vertices[ i ] );\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else if ( useFaces === true ) {\n\t\t\t\t\t\n\t\t\t\t\tgeometry = object.geometry;\n\t\t\t\t\tfaces = geometry.faces;\n\t\t\t\t\t\n\t\t\t\t\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.addObjectData( object, faces[ i ] );\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tthis.addObjectData( object );\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\taddObjectData: function ( object, part ) {\n\t\t\t\n\t\t\tvar objectData = new THREE.OctreeObjectData( object, part );\n\t\t\t\n\t\t\t// add to tree objects data list\n\t\t\t\n\t\t\tthis.objectsData.push( objectData );\n\t\t\t\n\t\t\t// add to nodes\n\t\t\t\n\t\t\tthis.root.addObject( objectData );\n\t\t\t\n\t\t},\n\t\t\n\t\tremove: function ( object ) {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tobjectData = object,\n\t\t\t\tindex,\n\t\t\t\tobjectsDataRemoved;\n\t\t\t\n\t\t\t// ensure object is not object data for index search\n\t\t\t\n\t\t\tif ( object instanceof THREE.OctreeObjectData ) {\n\t\t\t\t\n\t\t\t\tobject = object.object;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// check uuid\n\t\t\t\n\t\t\tif ( this.objectsMap[ object.uuid ] ) {\n\t\t\t\t\n\t\t\t\tthis.objectsMap[ object.uuid ] = undefined;\n\t\t\t\t\n\t\t\t\t// check and remove from objects, nodes, and data lists\n\t\t\t\t\n\t\t\t\tindex = indexOfValue( this.objects, object );\n\t\t\t\t\n\t\t\t\tif ( index !== - 1 ) {\n\t\t\t\t\t\n\t\t\t\t\tthis.objects.splice( index, 1 );\n\t\t\t\t\t\n\t\t\t\t\t// remove from nodes\n\t\t\t\t\t\n\t\t\t\t\tobjectsDataRemoved = this.root.removeObject( objectData );\n\t\t\t\t\t\n\t\t\t\t\t// remove from objects data list\n\t\t\t\t\t\n\t\t\t\t\tfor ( i = 0, l = objectsDataRemoved.length; i < l; i ++ ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tobjectData = objectsDataRemoved[ i ];\n\t\t\t\t\t\t\n\t\t\t\t\t\tindex = indexOfValue( this.objectsData, objectData );\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( index !== - 1 ) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tthis.objectsData.splice( index, 1 );\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if ( this.objectsDeferred.length > 0 ) {\n\t\t\t\t\n\t\t\t\t// check and remove from deferred\n\t\t\t\t\n\t\t\t\tindex = indexOfPropertyWithValue( this.objectsDeferred, 'object', object );\n\t\t\t\t\n\t\t\t\tif ( index !== - 1 ) {\n\t\t\t\t\t\n\t\t\t\t\tthis.objectsDeferred.splice( index, 1 );\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\textend: function ( octree ) {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tobjectsData,\n\t\t\t\tobjectData;\n\t\t\t\t\n\t\t\tif ( octree instanceof THREE.Octree ) {\n\t\t\t\t\n\t\t\t\t// for each object data\n\t\t\t\t\n\t\t\t\tobjectsData = octree.objectsData;\n\t\t\t\t\n\t\t\t\tfor ( i = 0, l = objectsData.length; i < l; i ++ ) {\n\t\t\t\t\t\n\t\t\t\t\tobjectData = objectsData[ i ];\n\t\t\t\t\t\n\t\t\t\t\tthis.add( objectData, { useFaces: objectData.faces, useVertices: objectData.vertices } );\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\trebuild: function () {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tnode,\n\t\t\t\tobject,\n\t\t\t\tobjectData,\n\t\t\t\tindexOctant,\n\t\t\t\tindexOctantLast,\n\t\t\t\tobjectsUpdate = [];\n\t\t\t\n\t\t\t// check all object data for changes in position\n\t\t\t// assumes all object matrices are up to date\n\t\t\t\n\t\t\tfor ( i = 0, l = this.objectsData.length; i < l; i ++ ) {\n\t\t\t\t\n\t\t\t\tobjectData = this.objectsData[ i ];\n\t\t\t\t\n\t\t\t\tnode = objectData.node;\n\t\t\t\t\n\t\t\t\t// update object\n\t\t\t\t\n\t\t\t\tobjectData.update();\n\t\t\t\t\n\t\t\t\t// if position has changed since last organization of object in tree\n\t\t\t\t\n\t\t\t\tif ( node instanceof THREE.OctreeNode && ! objectData.positionLast.equals( objectData.position ) ) {\n\t\t\t\t\t\n\t\t\t\t\t// get octant index of object within current node\n\t\t\t\t\t\n\t\t\t\t\tindexOctantLast = objectData.indexOctant;\n\t\t\t\t\t\n\t\t\t\t\tindexOctant = node.getOctantIndex( objectData );\n\t\t\t\t\t\n\t\t\t\t\t// if object octant index has changed\n\t\t\t\t\t\n\t\t\t\t\tif ( indexOctant !== indexOctantLast ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// add to update list\n\t\t\t\t\t\t\n\t\t\t\t\t\tobjectsUpdate.push( objectData );\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// update changed objects\n\t\t\t\n\t\t\tfor ( i = 0, l = objectsUpdate.length; i < l; i ++ ) {\n\t\t\t\t\n\t\t\t\tobjectData = objectsUpdate[ i ];\n\t\t\t\t\n\t\t\t\t// remove object from current node\n\t\t\t\t\n\t\t\t\tobjectData.node.removeObject( objectData );\n\t\t\t\t\n\t\t\t\t// add object to tree root\n\t\t\t\t\n\t\t\t\tthis.root.addObject( objectData );\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\tupdateObject: function ( object ) {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tparentCascade = [ object ],\n\t\t\t\tparent,\n\t\t\t\tparentUpdate;\n\t\t\t\n\t\t\t// search all parents between object and root for world matrix update\n\t\t\t\n\t\t\tparent = object.parent;\n\t\t\t\n\t\t\twhile ( parent ) {\n\t\t\t\t\n\t\t\t\tparentCascade.push( parent );\n\t\t\t\tparent = parent.parent;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor ( i = 0, l = parentCascade.length; i < l; i ++ ) {\n\t\t\t\t\n\t\t\t\tparent = parentCascade[ i ];\n\t\t\t\t\n\t\t\t\tif ( parent.matrixWorldNeedsUpdate === true ) {\n\t\t\t\t\t\n\t\t\t\t\tparentUpdate = parent;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// update world matrix starting at uppermost parent that needs update\n\t\t\t\n\t\t\tif ( typeof parentUpdate !== 'undefined' ) {\n\t\t\t\t\n\t\t\t\tparentUpdate.updateMatrixWorld();\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\tsearch: function ( position, radius, organizeByObject, direction ) {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tnode,\n\t\t\t\tobjects,\n\t\t\t\tobjectData,\n\t\t\t\tobject,\n\t\t\t\tresults,\n\t\t\t\tresultData,\n\t\t\t\tresultsObjectsIndices,\n\t\t\t\tresultObjectIndex,\n\t\t\t\tdirectionPct;\n\t\t\t\n\t\t\t// add root objects\n\t\t\t\n\t\t\tobjects = [].concat( this.root.objects );\n\t\t\t\n\t\t\t// ensure radius (i.e. distance of ray) is a number\n\t\t\t\n\t\t\tif ( ! ( radius > 0 ) ) {\n\t\t\t\t\n\t\t\t\tradius = Number.MAX_VALUE;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// if direction passed, normalize and find pct\n\t\t\t\n\t\t\tif ( direction instanceof THREE.Vector3 ) {\n\t\t\t\t\n\t\t\t\tdirection = this.utilVec31Search.copy( direction ).normalize();\n\t\t\t\tdirectionPct = this.utilVec32Search.set( 1, 1, 1 ).divide( direction );\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// search each node of root\n\t\t\t\n\t\t\tfor ( i = 0, l = this.root.nodesIndices.length; i < l; i ++ ) {\n\t\t\t\t\n\t\t\t\tnode = this.root.nodesByIndex[ this.root.nodesIndices[ i ] ];\n\t\t\t\t\n\t\t\t\tobjects = node.search( position, radius, objects, direction, directionPct );\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// if should organize results by object\n\t\t\t\n\t\t\tif ( organizeByObject === true ) {\n\t\t\t\t\n\t\t\t\tresults = [];\n\t\t\t\tresultsObjectsIndices = [];\n\t\t\t\t\n\t\t\t\t// for each object data found\n\t\t\t\t\n\t\t\t\tfor ( i = 0, l = objects.length; i < l; i ++ ) {\n\t\t\t\t\t\n\t\t\t\t\tobjectData = objects[ i ];\n\t\t\t\t\tobject = objectData.object;\n\t\t\t\t\t\n\t\t\t\t\tresultObjectIndex = indexOfValue( resultsObjectsIndices, object );\n\t\t\t\t\t\n\t\t\t\t\t// if needed, create new result data\n\t\t\t\t\t\n\t\t\t\t\tif ( resultObjectIndex === - 1 ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tresultData = {\n\t\t\t\t\t\t\tobject: object,\n\t\t\t\t\t\t\tfaces: [],\n\t\t\t\t\t\t\tvertices: []\n\t\t\t\t\t\t};\n\t\t\t\t\t\t\n\t\t\t\t\t\tresults.push( resultData );\n\t\t\t\t\t\t\n\t\t\t\t\t\tresultsObjectsIndices.push( object );\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\tresultData = results[ resultObjectIndex ];\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// object data has faces or vertices, add to list\n\t\t\t\t\t\n\t\t\t\t\tif ( objectData.faces ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tresultData.faces.push( objectData.faces );\n\t\t\t\t\t\t\n\t\t\t\t\t} else if ( objectData.vertices ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tresultData.vertices.push( objectData.vertices );\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tresults = objects;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn results;\n\t\t\t\n\t\t},\n\t\t\n\t\tsetRoot: function ( root ) { \n\t\t\t\n\t\t\tif ( root instanceof THREE.OctreeNode ) {\n\t\t\t\t\n\t\t\t\t// store new root\n\t\t\t\t\n\t\t\t\tthis.root = root;\n\t\t\t\t\n\t\t\t\t// update properties\n\t\t\t\t\n\t\t\t\tthis.root.updateProperties();\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\tgetDepthEnd: function () {\n\t\t\t\n\t\t\treturn this.root.getDepthEnd();\n\t\t\t\n\t\t},\n\t\t\n\t\tgetNodeCountEnd: function () {\n\t\t\t\n\t\t\treturn this.root.getNodeCountEnd();\n\t\t\t\n\t\t},\n\t\t\n\t\tgetObjectCountEnd: function () {\n\t\t\t\n\t\t\treturn this.root.getObjectCountEnd();\n\t\t\t\n\t\t},\n\t\t\n\t\ttoConsole: function () {\n\t\t\t\n\t\t\tthis.root.toConsole();\n\t\t\t\n\t\t}\n\t\t\n\t};\n\n\t/*===================================================\n\n\tobject data\n\n\t=====================================================*/\n\n\tTHREE.OctreeObjectData = function ( object, part ) {\n\t\t\n\t\t// properties\n\t\t\n\t\tthis.object = object;\n\t\t\n\t\t// handle part by type\n\t\t\n\t\tif ( part instanceof THREE.Face3 ) {\n\t\t\t\n\t\t\tthis.faces = part;\n\t\t\tthis.face3 = true;\n\t\t\tthis.utilVec31FaceBounds = new THREE.Vector3();\n\t\t\t\n\t\t} else if ( part instanceof THREE.Vector3 ) {\n\t\t\t\n\t\t\tthis.vertices = part;\n\t\t\t\n\t\t}\n\t\t\n\t\tthis.radius = 0;\n\t\tthis.position = new THREE.Vector3();\n\t\t\t\n\t\t// initial update\n\t\t\n\t\tif ( this.object instanceof THREE.Object3D ) {\n\t\t\t\n\t\t\tthis.update();\n\t\t\t\n\t\t}\n\t\t\n\t\tthis.positionLast = this.position.clone();\n\t\t\n\t};\n\n\tTHREE.OctreeObjectData.prototype = {\n\t\t\n\t\tupdate: function () {\n\t\t\t\n\t\t\tif ( this.face3 ) {\n\t\t\t\t\n\t\t\t\tthis.radius = this.getFace3BoundingRadius( this.object, this.faces );\n\t\t\t\tthis.position.copy( this.faces.centroid ).applyMatrix4( this.object.matrixWorld );\n\t\t\t\t\n\t\t\t} else if ( this.vertices ) {\n\t\t\t\t\n\t\t\t\tthis.radius = this.object.material.size || 1;\n\t\t\t\tthis.position.copy( this.vertices ).applyMatrix4( this.object.matrixWorld );\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tif ( this.object.geometry ) {\n\t\t\t\t\t\n\t\t\t\t\tif ( this.object.geometry.boundingSphere === null ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.object.geometry.computeBoundingSphere();\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tthis.radius = this.object.geometry.boundingSphere.radius;\n\t\t\t\t\tthis.position.copy( this.object.geometry.boundingSphere.center ).applyMatrix4( this.object.matrixWorld );\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tthis.radius = this.object.boundRadius;\n\t\t\t\t\tthis.position.setFromMatrixPosition( this.object.matrixWorld );\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tthis.radius = this.radius * Math.max( this.object.scale.x, this.object.scale.y, this.object.scale.z );\n\t\t\t\n\t\t},\n\t\t\n\t\tgetFace3BoundingRadius: function ( object, face ) {\n\n\t\t\tif ( face.centroid === undefined ) face.centroid = new THREE.Vector3();\n\t\t\t\n\t\t\tvar geometry = object.geometry || object,\n\t\t\t\tvertices = geometry.vertices,\n\t\t\t\tcentroid = face.centroid,\n\t\t\t\tva = vertices[ face.a ], vb = vertices[ face.b ], vc = vertices[ face.c ],\n\t\t\t\tcentroidToVert = this.utilVec31FaceBounds,\n\t\t\t\tradius;\n\t\t\t\t\n\t\t\tcentroid.addVectors( va, vb ).add( vc ).divideScalar( 3 );\n\t\t\tradius = Math.max( centroidToVert.subVectors( centroid, va ).length(), centroidToVert.subVectors( centroid, vb ).length(), centroidToVert.subVectors( centroid, vc ).length() );\n\t\t\t\n\t\t\treturn radius;\n\t\t\t\n\t\t}\n\t\t\n\t};\n\n\t/*===================================================\n\n\tnode\n\n\t=====================================================*/\n\n\tTHREE.OctreeNode = function ( parameters ) {\n\t\t\n\t\t// utility\n\t\t\n\t\tthis.utilVec31Branch = new THREE.Vector3();\n\t\tthis.utilVec31Expand = new THREE.Vector3();\n\t\tthis.utilVec31Ray = new THREE.Vector3();\n\t\t\n\t\t// handle parameters\n\t\t\n\t\tparameters = parameters || {};\n\t\t\n\t\t// store or create tree\n\t\t\n\t\tif ( parameters.tree instanceof THREE.Octree ) {\n\t\t\t\n\t\t\tthis.tree = parameters.tree;\n\t\t\t\n\t\t} else if ( parameters.parent instanceof THREE.OctreeNode !== true ) {\n\t\t\t\n\t\t\tparameters.root = this;\n\t\t\t\n\t\t\tthis.tree = new THREE.Octree( parameters );\n\t\t\t\n\t\t}\n\t\t\n\t\t// basic properties\n\t\t\n\t\tthis.id = this.tree.nodeCount ++;\n\t\tthis.position = parameters.position instanceof THREE.Vector3 ? parameters.position : new THREE.Vector3();\n\t\tthis.radius = parameters.radius > 0 ? parameters.radius : 1;\n\t\tthis.indexOctant = parameters.indexOctant;\n\t\tthis.depth = 0;\n\t\t\n\t\t// reset and assign parent\n\t\t\n\t\tthis.reset();\n\t\tthis.setParent( parameters.parent );\n\t\t\n\t\t// additional properties\n\t\t\n\t\tthis.overlap = this.radius * this.tree.overlapPct;\n\t\tthis.radiusOverlap = this.radius + this.overlap;\n\t\tthis.left = this.position.x - this.radiusOverlap;\n\t\tthis.right = this.position.x + this.radiusOverlap;\n\t\tthis.bottom = this.position.y - this.radiusOverlap;\n\t\tthis.top = this.position.y + this.radiusOverlap;\n\t\tthis.back = this.position.z - this.radiusOverlap;\n\t\tthis.front = this.position.z + this.radiusOverlap;\n\t\t\n\t\t// visual\n\t\t\n\t\tif ( this.tree.scene ) {\n\t\t\t\n\t\t\tthis.visual = new THREE.Mesh( this.tree.visualGeometry, this.tree.visualMaterial );\n\t\t\tthis.visual.scale.set( this.radiusOverlap * 2, this.radiusOverlap * 2, this.radiusOverlap * 2 );\n\t\t\tthis.visual.position.copy( this.position );\n\t\t\tthis.tree.scene.add( this.visual );\n\t\t\t\n\t\t}\n\t\t\n\t};\n\n\tTHREE.OctreeNode.prototype = {\n\t\t\n\t\tsetParent: function ( parent ) {\n\t\t\t\n\t\t\t// store new parent\n\t\t\t\n\t\t\tif ( parent !== this && this.parent !== parent ) {\n\t\t\t\t\n\t\t\t\tthis.parent = parent;\n\t\t\t\t\n\t\t\t\t// update properties\n\t\t\t\t\n\t\t\t\tthis.updateProperties();\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\tupdateProperties: function () {\n\t\t\t\n\t\t\tvar i, l;\n\t\t\t\n\t\t\t// properties\n\t\t\t\n\t\t\tif ( this.parent instanceof THREE.OctreeNode ) {\n\t\t\t\t\n\t\t\t\tthis.tree = this.parent.tree;\n\t\t\t\tthis.depth = this.parent.depth + 1;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tthis.depth = 0;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// cascade\n\t\t\t\n\t\t\tfor ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {\n\t\t\t\t\n\t\t\t\tthis.nodesByIndex[ this.nodesIndices[ i ] ].updateProperties();\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\treset: function ( cascade, removeVisual ) {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tnode,\n\t\t\t\tnodesIndices = this.nodesIndices || [],\n\t\t\t\tnodesByIndex = this.nodesByIndex;\n\t\t\t\n\t\t\tthis.objects = [];\n\t\t\tthis.nodesIndices = [];\n\t\t\tthis.nodesByIndex = {};\n\t\t\t\n\t\t\t// unset parent in nodes\n\t\t\t\n\t\t\tfor ( i = 0, l = nodesIndices.length; i < l; i ++ ) {\n\t\t\t\t\n\t\t\t\tnode = nodesByIndex[ nodesIndices[ i ] ];\n\t\t\t\t\n\t\t\t\tnode.setParent( undefined );\n\t\t\t\t\n\t\t\t\tif ( cascade === true ) {\n\t\t\t\t\t\n\t\t\t\t\tnode.reset( cascade, removeVisual );\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// visual\n\t\t\t\n\t\t\tif ( removeVisual === true && this.visual && this.visual.parent ) {\n\t\t\t\t\n\t\t\t\tthis.visual.parent.remove( this.visual );\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\taddNode: function ( node, indexOctant ) {\n\t\t\t\n\t\t\tnode.indexOctant = indexOctant;\n\t\t\t\n\t\t\tif ( indexOfValue( this.nodesIndices, indexOctant ) === - 1 ) {\n\t\t\t\t\n\t\t\t\tthis.nodesIndices.push( indexOctant );\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tthis.nodesByIndex[ indexOctant ] = node;\n\t\t\t\n\t\t\tif ( node.parent !== this ) {\n\t\t\t\t\n\t\t\t\tnode.setParent( this );\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\tremoveNode: function ( indexOctant ) {\n\t\t\t\n\t\t\tvar index,\n\t\t\t\tnode;\n\t\t\t\t\n\t\t\tindex = indexOfValue( this.nodesIndices, indexOctant );\n\t\t\t\n\t\t\tthis.nodesIndices.splice( index, 1 );\n\t\t\t\n\t\t\tnode = node || this.nodesByIndex[ indexOctant ];\n\t\t\t\n\t\t\tdelete this.nodesByIndex[ indexOctant ];\n\t\t\t\n\t\t\tif ( node.parent === this ) {\n\t\t\t\t\n\t\t\t\tnode.setParent( undefined );\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\taddObject: function ( object ) {\n\t\t\t\n\t\t\tvar index,\n\t\t\t\tindexOctant,\n\t\t\t\tnode;\n\t\t\t\n\t\t\t// get object octant index\n\t\t\t\n\t\t\tindexOctant = this.getOctantIndex( object );\n\t\t\t\n\t\t\t// if object fully contained by an octant, add to subtree\n\t\t\tif ( indexOctant > - 1 && this.nodesIndices.length > 0 ) {\n\t\t\t\t\n\t\t\t\tnode = this.branch( indexOctant );\n\t\t\t\t\n\t\t\t\tnode.addObject( object );\n\t\t\t\t\n\t\t\t} else if ( indexOctant < - 1 && this.parent instanceof THREE.OctreeNode ) {\n\t\t\t\t\n\t\t\t\t// if object lies outside bounds, add to parent node\n\t\t\t\t\n\t\t\t\tthis.parent.addObject( object );\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// add to this objects list\n\t\t\t\t\n\t\t\t\tindex = indexOfValue( this.objects, object );\n\t\t\t\t\n\t\t\t\tif ( index === - 1 ) {\n\t\t\t\t\t\n\t\t\t\t\tthis.objects.push( object );\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// node reference\n\t\t\t\t\n\t\t\t\tobject.node = this;\n\t\t\t\t\n\t\t\t\t// check if need to expand, split, or both\n\t\t\t\t\n\t\t\t\tthis.checkGrow();\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\taddObjectWithoutCheck: function ( objects ) {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tobject;\n\n\t\t\tfor ( i = 0, l = objects.length; i < l; i ++ ) {\n\t\t\t\t\n\t\t\t\tobject = objects[ i ];\n\t\t\t\t\n\t\t\t\tthis.objects.push( object );\n\t\t\t\t\n\t\t\t\tobject.node = this;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\tremoveObject: function ( object ) {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tnodesRemovedFrom,\n\t\t\t\tremoveData;\n\t\t\t\n\t\t\t// cascade through tree to find and remove object\n\t\t\t\n\t\t\tremoveData = this.removeObjectRecursive( object, { searchComplete: false, nodesRemovedFrom: [], objectsDataRemoved: [] } );\n\t\t\t\n\t\t\t// if object removed, try to shrink the nodes it was removed from\n\t\t\t\n\t\t\tnodesRemovedFrom = removeData.nodesRemovedFrom;\n\t\t\t\n\t\t\tif ( nodesRemovedFrom.length > 0 ) {\n\t\t\t\t\n\t\t\t\tfor ( i = 0, l = nodesRemovedFrom.length; i < l; i ++ ) {\n\t\t\t\t\t\n\t\t\t\t\tnodesRemovedFrom[ i ].shrink();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn removeData.objectsDataRemoved;\n\t\t\t\n\t\t},\n\t\t\n\t\tremoveObjectRecursive: function ( object, removeData ) {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tindex = - 1,\n\t\t\t\tobjectData,\n\t\t\t\tnode,\n\t\t\t\tobjectRemoved;\n\t\t\t\n\t\t\t// find index of object in objects list\n\t\t\t\n\t\t\t// search and remove object data (fast)\n\t\t\tif ( object instanceof THREE.OctreeObjectData ) {\n\t\t\t\t\n\t\t\t\t// remove from this objects list\n\t\t\t\t\n\t\t\t\tindex = indexOfValue( this.objects, object );\n\t\t\t\t\n\t\t\t\tif ( index !== - 1 ) {\n\t\t\t\t\t\n\t\t\t\t\tthis.objects.splice( index, 1 );\n\t\t\t\t\tobject.node = undefined;\n\t\t\t\t\t\n\t\t\t\t\tremoveData.objectsDataRemoved.push( object );\n\t\t\t\t\t\n\t\t\t\t\tremoveData.searchComplete = objectRemoved = true;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\n\t\t\t\t// search each object data for object and remove (slow)\n\t\t\t\t\n\t\t\t\tfor ( i = this.objects.length - 1; i >= 0; i -- ) {\n\t\t\t\t\t\n\t\t\t\t\tobjectData = this.objects[ i ];\n\t\t\t\t\t\n\t\t\t\t\tif ( objectData.object === object ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.objects.splice( i, 1 );\n\t\t\t\t\t\tobjectData.node = undefined;\n\t\t\t\t\t\t\n\t\t\t\t\t\tremoveData.objectsDataRemoved.push( objectData );\n\t\t\t\t\t\t\n\t\t\t\t\t\tobjectRemoved = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( ! objectData.faces && ! objectData.vertices ) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tremoveData.searchComplete = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// if object data removed and this is not on nodes removed from\n\t\t\t\n\t\t\tif ( objectRemoved === true ) {\n\t\t\t\t\n\t\t\t\tremoveData.nodesRemovedFrom.push( this );\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// if search not complete, search nodes\n\t\t\t\n\t\t\tif ( removeData.searchComplete !== true ) {\n\t\t\t\t\n\t\t\t\tfor ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {\n\t\t\t\t\t\n\t\t\t\t\tnode = this.nodesByIndex[ this.nodesIndices[ i ] ];\n\t\t\t\t\t\n\t\t\t\t\t// try removing object from node\n\t\t\t\t\t\n\t\t\t\t\tremoveData = node.removeObjectRecursive( object, removeData );\n\t\t\t\t\t\n\t\t\t\t\tif ( removeData.searchComplete === true ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn removeData;\n\t\t\t\n\t\t},\n\t\t\n\t\tcheckGrow: function () {\n\t\t\t\n\t\t\t// if object count above max\n\t\t\t\n\t\t\tif ( this.objects.length > this.tree.objectsThreshold && this.tree.objectsThreshold > 0 ) {\n\t\t\t\t\n\t\t\t\tthis.grow();\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\tgrow: function () {\n\t\t\t\n\t\t\tvar indexOctant,\n\t\t\t\tobject,\n\t\t\t\tobjectsExpand = [],\n\t\t\t\tobjectsExpandOctants = [],\n\t\t\t\tobjectsSplit = [],\n\t\t\t\tobjectsSplitOctants = [],\n\t\t\t\tobjectsRemaining = [],\n\t\t\t\ti, l;\n\t\t\t\n\t\t\t// for each object\n\t\t\t\n\t\t\tfor ( i = 0, l = this.objects.length; i < l; i ++ ) {\n\t\t\t\t\n\t\t\t\tobject = this.objects[ i ];\n\t\t\t\t\n\t\t\t\t// get object octant index\n\t\t\t\t\n\t\t\t\tindexOctant = this.getOctantIndex( object );\n\t\t\t\t\n\t\t\t\t// if lies within octant\n\t\t\t\tif ( indexOctant > - 1 ) {\n\t\t\t\t\t\n\t\t\t\t\tobjectsSplit.push( object );\n\t\t\t\t\tobjectsSplitOctants.push( indexOctant );\n\t\t\t\t\n\t\t\t\t} else if ( indexOctant < - 1 ) {\n\t\t\t\t\t\n\t\t\t\t\t// lies outside radius\n\t\t\t\t\t\n\t\t\t\t\tobjectsExpand.push( object );\n\t\t\t\t\tobjectsExpandOctants.push( indexOctant );\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\n\t\t\t\t\t// lies across bounds between octants\n\t\t\t\t\t\n\t\t\t\t\tobjectsRemaining.push( object );\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// if has objects to split\n\t\t\t\n\t\t\tif ( objectsSplit.length > 0 ) {\n\t\t\t\t\n\t\t\t\tobjectsRemaining = objectsRemaining.concat( this.split( objectsSplit, objectsSplitOctants ) );\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// if has objects to expand\n\t\t\t\n\t\t\tif ( objectsExpand.length > 0 ) {\n\t\t\t\t\n\t\t\t\tobjectsRemaining = objectsRemaining.concat( this.expand( objectsExpand, objectsExpandOctants ) );\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// store remaining\n\t\t\t\n\t\t\tthis.objects = objectsRemaining;\n\t\t\t\n\t\t\t// merge check\n\t\t\t\n\t\t\tthis.checkMerge();\n\t\t\t\n\t\t},\n\t\t\n\t\tsplit: function ( objects, octants ) {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tindexOctant,\n\t\t\t\tobject,\n\t\t\t\tnode,\n\t\t\t\tobjectsRemaining;\n\t\t\t\n\t\t\t// if not at max depth\n\t\t\t\n\t\t\tif ( this.depth < this.tree.depthMax ) {\n\t\t\t\t\n\t\t\t\tobjects = objects || this.objects;\n\t\t\t\t\n\t\t\t\toctants = octants || [];\n\t\t\t\t\n\t\t\t\tobjectsRemaining = [];\n\t\t\t\t\n\t\t\t\t// for each object\n\t\t\t\t\n\t\t\t\tfor ( i = 0, l = objects.length; i < l; i ++ ) {\n\t\t\t\t\t\n\t\t\t\t\tobject = objects[ i ];\n\t\t\t\t\t\n\t\t\t\t\t// get object octant index\n\t\t\t\t\t\n\t\t\t\t\tindexOctant = octants[ i ];\n\t\t\t\t\t\n\t\t\t\t\t// if object contained by octant, branch this tree\n\t\t\t\t\t\n\t\t\t\t\tif ( indexOctant > - 1 ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tnode = this.branch( indexOctant );\n\t\t\t\t\t\t\n\t\t\t\t\t\tnode.addObject( object );\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\tobjectsRemaining.push( object );\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// if all objects, set remaining as new objects\n\t\t\t\t\n\t\t\t\tif ( objects === this.objects ) {\n\t\t\t\t\t\n\t\t\t\t\tthis.objects = objectsRemaining;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tobjectsRemaining = this.objects;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn objectsRemaining;\n\t\t\t\n\t\t},\n\t\t\n\t\tbranch: function ( indexOctant ) {\n\t\t\t\n\t\t\tvar node,\n\t\t\t\toverlap,\n\t\t\t\tradius,\n\t\t\t\tradiusOffset,\n\t\t\t\toffset,\n\t\t\t\tposition;\n\t\t\t\n\t\t\t// node exists\n\t\t\t\n\t\t\tif ( this.nodesByIndex[ indexOctant ] instanceof THREE.OctreeNode ) {\n\t\t\t\t\n\t\t\t\tnode = this.nodesByIndex[ indexOctant ];\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// properties\n\t\t\t\t\n\t\t\t\tradius = ( this.radiusOverlap ) * 0.5;\n\t\t\t\toverlap = radius * this.tree.overlapPct;\n\t\t\t\tradiusOffset = radius - overlap;\n\t\t\t\toffset = this.utilVec31Branch.set( indexOctant & 1 ? radiusOffset : - radiusOffset, indexOctant & 2 ? radiusOffset : - radiusOffset, indexOctant & 4 ? radiusOffset : - radiusOffset );\n\t\t\t\tposition = new THREE.Vector3().addVectors( this.position, offset );\n\t\t\t\t\n\t\t\t\t// node\n\t\t\t\t\n\t\t\t\tnode = new THREE.OctreeNode( {\n\t\t\t\t\ttree: this.tree,\n\t\t\t\t\tparent: this,\n\t\t\t\t\tposition: position,\n\t\t\t\t\tradius: radius,\n\t\t\t\t\tindexOctant: indexOctant\n\t\t\t\t} );\n\t\t\t\t\n\t\t\t\t// store\n\t\t\t\t\n\t\t\t\tthis.addNode( node, indexOctant );\n\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn node;\n\t\t\t\n\t\t},\n\t\t\n\t\texpand: function ( objects, octants ) {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tobject,\n\t\t\t\tobjectsRemaining,\n\t\t\t\tobjectsExpand,\n\t\t\t\tindexOctant,\n\t\t\t\tflagsOutside,\n\t\t\t\tindexOutside,\n\t\t\t\tindexOctantInverse,\n\t\t\t\tiom = this.tree.INDEX_OUTSIDE_MAP,\n\t\t\t\tindexOutsideCounts,\n\t\t\t\tinfoIndexOutside1,\n\t\t\t\tinfoIndexOutside2,\n\t\t\t\tinfoIndexOutside3,\n\t\t\t\tindexOutsideBitwise1,\n\t\t\t\tindexOutsideBitwise2,\n\t\t\t\tinfoPotential1,\n\t\t\t\tinfoPotential2,\n\t\t\t\tinfoPotential3,\n\t\t\t\tindexPotentialBitwise1,\n\t\t\t\tindexPotentialBitwise2,\n\t\t\t\toctantX, octantY, octantZ,\n\t\t\t\toverlap,\n\t\t\t\tradius,\n\t\t\t\tradiusOffset,\n\t\t\t\tradiusParent,\n\t\t\t\toverlapParent,\n\t\t\t\toffset = this.utilVec31Expand,\n\t\t\t\tposition,\n\t\t\t\tparent;\n\t\t\t\n\t\t\t// handle max depth down tree\n\t\t\t\n\t\t\tif ( this.tree.root.getDepthEnd() < this.tree.depthMax ) {\n\t\t\t\t\n\t\t\t\tobjects = objects || this.objects;\n\t\t\t\toctants = octants || [];\n\t\t\t\t\n\t\t\t\tobjectsRemaining = [];\n\t\t\t\tobjectsExpand = [];\n\t\t\t\t\n\t\t\t\t// reset counts\n\t\t\t\t\n\t\t\t\tfor ( i = 0, l = iom.length; i < l; i ++ ) {\n\t\t\t\t\t\n\t\t\t\t\tiom[ i ].count = 0;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// for all outside objects, find outside octants containing most objects\n\t\t\t\t\n\t\t\t\tfor ( i = 0, l = objects.length; i < l; i ++ ) {\n\t\t\t\t\t\n\t\t\t\t\tobject = objects[ i ];\n\t\t\t\t\t\n\t\t\t\t\t// get object octant index\n\t\t\t\t\t\n\t\t\t\t\tindexOctant = octants[ i ] ;\n\t\t\t\t\t\n\t\t\t\t\t// if object outside this, include in calculations\n\t\t\t\t\t\n\t\t\t\t\tif ( indexOctant < - 1 ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// convert octant index to outside flags\n\t\t\t\t\t\t\n\t\t\t\t\t\tflagsOutside = - indexOctant - this.tree.INDEX_OUTSIDE_OFFSET;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// check against bitwise flags\n\t\t\t\t\t\t\n\t\t\t\t\t\t// x\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( flagsOutside & this.tree.FLAG_POS_X ) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tiom[ this.tree.INDEX_OUTSIDE_POS_X ].count ++;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if ( flagsOutside & this.tree.FLAG_NEG_X ) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tiom[ this.tree.INDEX_OUTSIDE_NEG_X ].count ++;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// y\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( flagsOutside & this.tree.FLAG_POS_Y ) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tiom[ this.tree.INDEX_OUTSIDE_POS_Y ].count ++;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if ( flagsOutside & this.tree.FLAG_NEG_Y ) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tiom[ this.tree.INDEX_OUTSIDE_NEG_Y ].count ++;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// z\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( flagsOutside & this.tree.FLAG_POS_Z ) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tiom[ this.tree.INDEX_OUTSIDE_POS_Z ].count ++;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if ( flagsOutside & this.tree.FLAG_NEG_Z ) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tiom[ this.tree.INDEX_OUTSIDE_NEG_Z ].count ++;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// store in expand list\n\t\t\t\t\t\t\n\t\t\t\t\t\tobjectsExpand.push( object );\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\tobjectsRemaining.push( object );\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// if objects to expand\n\t\t\t\t\n\t\t\t\tif ( objectsExpand.length > 0 ) {\n\t\t\t\t\t\n\t\t\t\t\t// shallow copy index outside map\n\t\t\t\t\t\n\t\t\t\t\tindexOutsideCounts = iom.slice( 0 );\n\t\t\t\t\t\n\t\t\t\t\t// sort outside index count so highest is first\n\t\t\t\t\t\n\t\t\t\t\tindexOutsideCounts.sort( function ( a, b ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn b.count - a.count;\n\t\t\t\t\t\t\n\t\t\t\t\t} );\n\t\t\t\t\t\n\t\t\t\t\t// get highest outside indices\n\t\t\t\t\t\n\t\t\t\t\t// first is first\n\t\t\t\t\tinfoIndexOutside1 = indexOutsideCounts[ 0 ];\n\t\t\t\t\tindexOutsideBitwise1 = infoIndexOutside1.index | 1;\n\t\t\t\t\t\n\t\t\t\t\t// second is ( one of next two bitwise OR 1 ) that is not opposite of ( first bitwise OR 1 )\n\t\t\t\t\t\n\t\t\t\t\tinfoPotential1 = indexOutsideCounts[ 1 ];\n\t\t\t\t\tinfoPotential2 = indexOutsideCounts[ 2 ];\n\t\t\t\t\t\n\t\t\t\t\tinfoIndexOutside2 = ( infoPotential1.index | 1 ) !== indexOutsideBitwise1 ? infoPotential1 : infoPotential2;\n\t\t\t\t\tindexOutsideBitwise2 = infoIndexOutside2.index | 1;\n\t\t\t\t\t\n\t\t\t\t\t// third is ( one of next three bitwise OR 1 ) that is not opposite of ( first or second bitwise OR 1 )\n\t\t\t\t\t\n\t\t\t\t\tinfoPotential1 = indexOutsideCounts[ 2 ];\n\t\t\t\t\tinfoPotential2 = indexOutsideCounts[ 3 ];\n\t\t\t\t\tinfoPotential3 = indexOutsideCounts[ 4 ];\n\t\t\t\t\t\n\t\t\t\t\tindexPotentialBitwise1 = infoPotential1.index | 1;\n\t\t\t\t\tindexPotentialBitwise2 = infoPotential2.index | 1;\n\t\t\t\t\t\n\t\t\t\t\tinfoIndexOutside3 = indexPotentialBitwise1 !== indexOutsideBitwise1 && indexPotentialBitwise1 !== indexOutsideBitwise2 ? infoPotential1 : indexPotentialBitwise2 !== indexOutsideBitwise1 && indexPotentialBitwise2 !== indexOutsideBitwise2 ? infoPotential2 : infoPotential3;\n\t\t\t\t\t\n\t\t\t\t\t// get this octant normal based on outside octant indices\n\t\t\t\t\t\n\t\t\t\t\toctantX = infoIndexOutside1.x + infoIndexOutside2.x + infoIndexOutside3.x;\n\t\t\t\t\toctantY = infoIndexOutside1.y + infoIndexOutside2.y + infoIndexOutside3.y;\n\t\t\t\t\toctantZ = infoIndexOutside1.z + infoIndexOutside2.z + infoIndexOutside3.z;\n\t\t\t\t\t\n\t\t\t\t\t// get this octant indices based on octant normal\n\t\t\t\t\t\n\t\t\t\t\tindexOctant = this.getOctantIndexFromPosition( octantX, octantY, octantZ );\n\t\t\t\t\tindexOctantInverse = this.getOctantIndexFromPosition( - octantX, - octantY, - octantZ );\n\t\t\t\t\t\n\t\t\t\t\t// properties\n\t\t\t\t\t\n\t\t\t\t\toverlap = this.overlap;\n\t\t\t\t\tradius = this.radius;\n\t\t\t\t\t\n\t\t\t\t\t// radius of parent comes from reversing overlap of this, unless overlap percent is 0\n\t\t\t\t\t\n\t\t\t\t\tradiusParent = this.tree.overlapPct > 0 ? overlap / ( ( 0.5 * this.tree.overlapPct ) * ( 1 + this.tree.overlapPct ) ) : radius * 2; \n\t\t\t\t\toverlapParent = radiusParent * this.tree.overlapPct;\n\t\t\t\t\t\n\t\t\t\t\t// parent offset is difference between radius + overlap of parent and child\n\t\t\t\t\t\n\t\t\t\t\tradiusOffset = ( radiusParent + overlapParent ) - ( radius + overlap );\n\t\t\t\t\toffset.set( indexOctant & 1 ? radiusOffset : - radiusOffset, indexOctant & 2 ? radiusOffset : - radiusOffset, indexOctant & 4 ? radiusOffset : - radiusOffset );\n\t\t\t\t\tposition = new THREE.Vector3().addVectors( this.position, offset );\n\t\t\t\t\t\n\t\t\t\t\t// parent\n\t\t\t\t\t\n\t\t\t\t\tparent = new THREE.OctreeNode( {\n\t\t\t\t\t\ttree: this.tree,\n\t\t\t\t\t\tposition: position,\n\t\t\t\t\t\tradius: radiusParent\n\t\t\t\t\t} );\n\t\t\t\t\t\n\t\t\t\t\t// set self as node of parent\n\t\t\t\t\t\n\t\t\t\t\tparent.addNode( this, indexOctantInverse );\n\t\t\t\t\t\n\t\t\t\t\t// set parent as root\n\t\t\t\t\t\n\t\t\t\t\tthis.tree.setRoot( parent );\n\t\t\t\t\t\n\t\t\t\t\t// add all expand objects to parent\n\t\t\t\t\t\n\t\t\t\t\tfor ( i = 0, l = objectsExpand.length; i < l; i ++ ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.tree.root.addObject( objectsExpand[ i ] );\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// if all objects, set remaining as new objects\n\t\t\t\t\n\t\t\t\tif ( objects === this.objects ) {\n\t\t\t\t\t\n\t\t\t\t\tthis.objects = objectsRemaining;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tobjectsRemaining = objects;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn objectsRemaining;\n\t\t\t\n\t\t},\n\t\t\n\t\tshrink: function () {\n\t\t\t\n\t\t\t// merge check\n\t\t\t\n\t\t\tthis.checkMerge();\n\t\t\t\n\t\t\t// contract check\n\t\t\t\n\t\t\tthis.tree.root.checkContract();\n\t\t\t\n\t\t},\n\t\t\n\t\tcheckMerge: function () {\n\t\t\t\n\t\t\tvar nodeParent = this,\n\t\t\t\tnodeMerge;\n\t\t\t\n\t\t\t// traverse up tree as long as node + entire subtree's object count is under minimum\n\t\t\t\n\t\t\twhile ( nodeParent.parent instanceof THREE.OctreeNode && nodeParent.getObjectCountEnd() < this.tree.objectsThreshold ) {\n\t\t\t\t\n\t\t\t\tnodeMerge = nodeParent;\n\t\t\t\tnodeParent = nodeParent.parent;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// if parent node is not this, merge entire subtree into merge node\n\t\t\t\n\t\t\tif ( nodeParent !== this ) {\n\t\t\t\t\n\t\t\t\tnodeParent.merge( nodeMerge );\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\tmerge: function ( nodes ) {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tj, k,\n\t\t\t\tnode;\n\t\t\t\n\t\t\t// handle nodes\n\t\t\t\n\t\t\tnodes = toArray( nodes );\n\t\t\t\n\t\t\tfor ( i = 0, l = nodes.length; i < l; i ++ ) {\n\t\t\t\t\n\t\t\t\tnode = nodes[ i ];\n\t\t\t\t\n\t\t\t\t// gather node + all subtree objects\n\t\t\t\t\n\t\t\t\tthis.addObjectWithoutCheck( node.getObjectsEnd() );\n\t\t\t\t\n\t\t\t\t// reset node + entire subtree\n\t\t\t\t\n\t\t\t\tnode.reset( true, true );\n\t\t\t\t\n\t\t\t\t// remove node\n\t\t\t\t\n\t\t\t\tthis.removeNode( node.indexOctant, node );\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// merge check\n\t\t\t\n\t\t\tthis.checkMerge();\n\t\t\t\n\t\t},\n\t\t\n\t\tcheckContract: function () {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tnode,\n\t\t\t\tnodeObjectsCount,\n\t\t\t\tnodeHeaviest,\n\t\t\t\tnodeHeaviestObjectsCount,\n\t\t\t\toutsideHeaviestObjectsCount;\n\t\t\t\n\t\t\t// find node with highest object count\n\t\t\t\n\t\t\tif ( this.nodesIndices.length > 0 ) {\n\t\t\t\t\n\t\t\t\tnodeHeaviestObjectsCount = 0;\n\t\t\t\toutsideHeaviestObjectsCount = this.objects.length;\n\t\t\t\t\n\t\t\t\tfor ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {\n\t\t\t\t\t\n\t\t\t\t\tnode = this.nodesByIndex[ this.nodesIndices[ i ] ];\n\t\t\t\t\t\n\t\t\t\t\tnodeObjectsCount = node.getObjectCountEnd();\n\t\t\t\t\toutsideHeaviestObjectsCount += nodeObjectsCount;\n\t\t\t\t\t\n\t\t\t\t\tif ( nodeHeaviest instanceof THREE.OctreeNode === false || nodeObjectsCount > nodeHeaviestObjectsCount ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tnodeHeaviest = node;\n\t\t\t\t\t\tnodeHeaviestObjectsCount = nodeObjectsCount;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// subtract heaviest count from outside count\n\t\t\t\t\n\t\t\t\toutsideHeaviestObjectsCount -= nodeHeaviestObjectsCount;\n\t\t\t\t\n\t\t\t\t// if should contract\n\t\t\t\t\n\t\t\t\tif ( outsideHeaviestObjectsCount < this.tree.objectsThreshold && nodeHeaviest instanceof THREE.OctreeNode ) {\n\t\t\t\t\t\n\t\t\t\t\tthis.contract( nodeHeaviest );\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\tcontract: function ( nodeRoot ) {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tnode;\n\t\t\t\n\t\t\t// handle all nodes\n\t\t\t\n\t\t\tfor ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {\n\t\t\t\t\n\t\t\t\tnode = this.nodesByIndex[ this.nodesIndices[ i ] ];\n\t\t\t\t\n\t\t\t\t// if node is not new root\n\t\t\t\t\n\t\t\t\tif ( node !== nodeRoot ) {\n\t\t\t\t\t\n\t\t\t\t\t// add node + all subtree objects to root\n\t\t\t\t\t\n\t\t\t\t\tnodeRoot.addObjectWithoutCheck( node.getObjectsEnd() );\n\t\t\t\t\t\n\t\t\t\t\t// reset node + entire subtree\n\t\t\t\t\t\n\t\t\t\t\tnode.reset( true, true );\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// add own objects to root\n\t\t\t\n\t\t\tnodeRoot.addObjectWithoutCheck( this.objects );\n\t\t\t\n\t\t\t// reset self\n\t\t\t\n\t\t\tthis.reset( false, true );\n\t\t\t\n\t\t\t// set new root\n\t\t\t\n\t\t\tthis.tree.setRoot( nodeRoot );\n\t\t\t\n\t\t\t// contract check on new root\n\t\t\t\n\t\t\tnodeRoot.checkContract();\n\t\t\t\n\t\t},\n\t\t\n\t\tgetOctantIndex: function ( objectData ) {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tpositionObj,\n\t\t\t\tradiusObj,\n\t\t\t\tposition = this.position,\n\t\t\t\tradiusOverlap = this.radiusOverlap,\n\t\t\t\toverlap = this.overlap,\n\t\t\t\tdeltaX, deltaY, deltaZ,\n\t\t\t\tdistX, distY, distZ, \n\t\t\t\tdistance,\n\t\t\t\tindexOctant = 0;\n\t\t\t\n\t\t\t// handle type\n\t\t\t\n\t\t\tif ( objectData instanceof THREE.OctreeObjectData ) {\n\t\t\t\t\n\t\t\t\tradiusObj = objectData.radius;\n\t\t\t\t\n\t\t\t\tpositionObj = objectData.position;\n\t\t\t\t\n\t\t\t\t// update object data position last\n\t\t\t\t\n\t\t\t\tobjectData.positionLast.copy( positionObj );\n\t\t\t\t\n\t\t\t} else if ( objectData instanceof THREE.OctreeNode ) {\n\t\t\t\t\n\t\t\t\tpositionObj = objectData.position;\n\t\t\t\t\n\t\t\t\tradiusObj = 0;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// find delta and distance\n\t\t\t\n\t\t\tdeltaX = positionObj.x - position.x;\n\t\t\tdeltaY = positionObj.y - position.y;\n\t\t\tdeltaZ = positionObj.z - position.z;\n\t\t\t\n\t\t\tdistX = Math.abs( deltaX );\n\t\t\tdistY = Math.abs( deltaY );\n\t\t\tdistZ = Math.abs( deltaZ );\n\t\t\tdistance = Math.max( distX, distY, distZ );\n\t\t\t\n\t\t\t// if outside, use bitwise flags to indicate on which sides object is outside of\n\t\t\t\n\t\t\tif ( distance + radiusObj > radiusOverlap ) {\n\t\t\t\t\n\t\t\t\t// x\n\t\t\t\t\n\t\t\t\tif ( distX + radiusObj > radiusOverlap ) {\n\t\t\t\t\t\n\t\t\t\t\tindexOctant = indexOctant ^ ( deltaX > 0 ? this.tree.FLAG_POS_X : this.tree.FLAG_NEG_X );\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// y\n\t\t\t\t\n\t\t\t\tif ( distY + radiusObj > radiusOverlap ) {\n\t\t\t\t\t\n\t\t\t\t\tindexOctant = indexOctant ^ ( deltaY > 0 ? this.tree.FLAG_POS_Y : this.tree.FLAG_NEG_Y );\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// z\n\t\t\t\t\n\t\t\t\tif ( distZ + radiusObj > radiusOverlap ) {\n\t\t\t\t\t\n\t\t\t\t\tindexOctant = indexOctant ^ ( deltaZ > 0 ? this.tree.FLAG_POS_Z : this.tree.FLAG_NEG_Z );\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tobjectData.indexOctant = - indexOctant - this.tree.INDEX_OUTSIDE_OFFSET;\n\t\t\t\t\n\t\t\t\treturn objectData.indexOctant;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// return octant index from delta xyz\n\t\t\t\n\t\t\tif ( deltaX - radiusObj > - overlap ) {\n\t\t\t\t\n\t\t\t\t// x right\n\t\t\t\t\n\t\t\t\tindexOctant = indexOctant | 1;\n\t\t\t\t\n\t\t\t} else if ( ! ( deltaX + radiusObj < overlap ) ) {\n\t\t\t\t\n\t\t\t\t// x left\n\t\t\t\t\n\t\t\t\tobjectData.indexOctant = this.tree.INDEX_INSIDE_CROSS;\n\t\t\t\treturn objectData.indexOctant;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif ( deltaY - radiusObj > - overlap ) {\n\t\t\t\t\n\t\t\t\t// y right\n\t\t\t\t\n\t\t\t\tindexOctant = indexOctant | 2;\n\t\t\t\t\n\t\t\t} else if ( ! ( deltaY + radiusObj < overlap ) ) {\n\t\t\t\t\n\t\t\t\t// y left\n\t\t\t\t\n\t\t\t\tobjectData.indexOctant = this.tree.INDEX_INSIDE_CROSS;\n\t\t\t\treturn objectData.indexOctant;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif ( deltaZ - radiusObj > - overlap ) {\n\t\t\t\t\n\t\t\t\t// z right\n\t\t\t\t\n\t\t\t\tindexOctant = indexOctant | 4;\n\t\t\t\t\n\t\t\t} else if ( ! ( deltaZ + radiusObj < overlap ) ) {\n\t\t\t\t\n\t\t\t\t// z left\n\t\t\t\t\n\t\t\t\tobjectData.indexOctant = this.tree.INDEX_INSIDE_CROSS;\n\t\t\t\treturn objectData.indexOctant;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tobjectData.indexOctant = indexOctant;\n\t\t\treturn objectData.indexOctant;\n\t\t\t\n\t\t},\n\t\t\n\t\tgetOctantIndexFromPosition: function ( x, y, z ) {\n\t\t\t\n\t\t\tvar indexOctant = 0;\n\t\t\t\n\t\t\tif ( x > 0 ) {\n\t\t\t\t\n\t\t\t\tindexOctant = indexOctant | 1;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif ( y > 0 ) {\n\t\t\t\t\n\t\t\t\tindexOctant = indexOctant | 2;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif ( z > 0 ) {\n\t\t\t\t\n\t\t\t\tindexOctant = indexOctant | 4;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn indexOctant;\n\t\t\t\n\t\t},\n\t\t\n\t\tsearch: function ( position, radius, objects, direction, directionPct ) {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tnode,\n\t\t\t\tintersects;\n\t\t\t\n\t\t\t// test intersects by parameters\n\t\t\t\n\t\t\tif ( direction ) {\n\t\t\t\t\n\t\t\t\tintersects = this.intersectRay( position, direction, radius, directionPct );\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tintersects = this.intersectSphere( position, radius );\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// if intersects\n\t\t\t\n\t\t\tif ( intersects === true ) {\n\t\t\t\t\n\t\t\t\t// gather objects\n\t\t\t\t\n\t\t\t\tobjects = objects.concat( this.objects );\n\t\t\t\t\n\t\t\t\t// search subtree\n\t\t\t\t\n\t\t\t\tfor ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {\n\t\t\t\t\t\n\t\t\t\t\tnode = this.nodesByIndex[ this.nodesIndices[ i ] ];\n\t\t\t\t\t\n\t\t\t\t\tobjects = node.search( position, radius, objects, direction );\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn objects;\n\t\t\t\n\t\t},\n\t\t\n\t\tintersectSphere: function ( position, radius ) {\n\t\t\t\n\t\t\tvar\tdistance = radius * radius,\n\t\t\t\tpx = position.x,\n\t\t\t\tpy = position.y,\n\t\t\t\tpz = position.z;\n\t\t\t\n\t\t\tif ( px < this.left ) {\n\n\t\t\t\tdistance -= Math.pow( px - this.left, 2 );\n\n\t\t\t} else if ( px > this.right ) {\n\n\t\t\t\tdistance -= Math.pow( px - this.right, 2 );\n\n\t\t\t}\n\t\t\t\n\t\t\tif ( py < this.bottom ) {\n\n\t\t\t\tdistance -= Math.pow( py - this.bottom, 2 );\n\n\t\t\t} else if ( py > this.top ) {\n\n\t\t\t\tdistance -= Math.pow( py - this.top, 2 );\n\n\t\t\t}\n\t\t\t\n\t\t\tif ( pz < this.back ) {\n\n\t\t\t\tdistance -= Math.pow( pz - this.back, 2 );\n\n\t\t\t} else if ( pz > this.front ) {\n\n\t\t\t\tdistance -= Math.pow( pz - this.front, 2 );\n\n\t\t\t}\n\t\t\t\n\t\t\treturn distance >= 0;\n\t\t\t\n\t\t},\n\t\t\n\t\tintersectRay: function ( origin, direction, distance, directionPct ) {\n\t\t\t\n\t\t\tif ( typeof directionPct === 'undefined' ) {\n\t\t\t\t\n\t\t\t\tdirectionPct = this.utilVec31Ray.set( 1, 1, 1 ).divide( direction );\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tvar t1 = ( this.left - origin.x ) * directionPct.x,\n\t\t\t\tt2 = ( this.right - origin.x ) * directionPct.x,\n\t\t\t\tt3 = ( this.bottom - origin.y ) * directionPct.y,\n\t\t\t\tt4 = ( this.top - origin.y ) * directionPct.y,\n\t\t\t\tt5 = ( this.back - origin.z ) * directionPct.z,\n\t\t\t\tt6 = ( this.front - origin.z ) * directionPct.z,\n\t\t\t\ttmax = Math.min( Math.min( Math.max( t1, t2 ), Math.max( t3, t4 ) ), Math.max( t5, t6 ) ),\n\t\t\t\ttmin;\n\n\t\t\t// ray would intersect in reverse direction, i.e. this is behind ray\n\t\t\tif ( tmax < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\t\t\t\n\t\t\ttmin = Math.max( Math.max( Math.min( t1, t2 ), Math.min( t3, t4 ) ), Math.min( t5, t6 ) );\n\t\t\t\n\t\t\t// if tmin > tmax or tmin > ray distance, ray doesn't intersect AABB\n\t\t\tif ( tmin > tmax || tmin > distance ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t\t\n\t\t},\n\t\t\n\t\tgetDepthEnd: function ( depth ) {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tnode;\n\n\t\t\tif ( this.nodesIndices.length > 0 ) {\n\t\t\t\t\n\t\t\t\tfor ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {\n\n\t\t\t\t\tnode = this.nodesByIndex[ this.nodesIndices[ i ] ];\n\n\t\t\t\t\tdepth = node.getDepthEnd( depth );\n\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\n\t\t\t\tdepth = ! depth || this.depth > depth ? this.depth : depth;\n\n\t\t\t}\n\n\t\t\treturn depth;\n\t\t\t\n\t\t},\n\t\t\n\t\tgetNodeCountEnd: function () {\n\t\t\t\n\t\t\treturn this.tree.root.getNodeCountRecursive() + 1;\n\t\t\t\n\t\t},\n\t\t\n\t\tgetNodeCountRecursive: function () {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tcount = this.nodesIndices.length;\n\t\t\t\n\t\t\tfor ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {\n\t\t\t\t\n\t\t\t\tcount += this.nodesByIndex[ this.nodesIndices[ i ] ].getNodeCountRecursive();\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn count;\n\t\t\t\n\t\t},\n\t\t\n\t\tgetObjectsEnd: function ( objects ) {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tnode;\n\t\t\t\n\t\t\tobjects = ( objects || [] ).concat( this.objects );\n\t\t\t\n\t\t\tfor ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {\n\t\t\t\t\n\t\t\t\tnode = this.nodesByIndex[ this.nodesIndices[ i ] ];\n\t\t\t\t\n\t\t\t\tobjects = node.getObjectsEnd( objects );\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn objects;\n\t\t\t\n\t\t},\n\t\t\n\t\tgetObjectCountEnd: function () {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tcount = this.objects.length;\n\t\t\t\n\t\t\tfor ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {\n\t\t\t\t\n\t\t\t\tcount += this.nodesByIndex[ this.nodesIndices[ i ] ].getObjectCountEnd();\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn count;\n\t\t\t\n\t\t},\n\t\t\n\t\tgetObjectCountStart: function () {\n\t\t\t\n\t\t\tvar count = this.objects.length,\n\t\t\t\tparent = this.parent;\n\t\t\t\n\t\t\twhile ( parent instanceof THREE.OctreeNode ) {\n\t\t\t\t\n\t\t\t\tcount += parent.objects.length;\n\t\t\t\tparent = parent.parent;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\treturn count;\n\t\t\t\n\t\t},\n\t\t\n\t\ttoConsole: function ( space ) {\n\t\t\t\n\t\t\tvar i, l,\n\t\t\t\tnode,\n\t\t\t\tspaceAddition = '   ';\n\t\t\t\n\t\t\tspace = typeof space === 'string' ? space : spaceAddition;\n\t\t\t\n\t\t\tconsole.log( ( this.parent ? space + ' octree NODE > ' : ' octree ROOT > ' ), this, ' // id: ', this.id, ' // indexOctant: ', this.indexOctant, ' // position: ', this.position.x, this.position.y, this.position.z, ' // radius: ', this.radius, ' // depth: ', this.depth );\n\t\t\tconsole.log( ( this.parent ? space + ' ' : ' ' ), '+ objects ( ', this.objects.length, ' ) ', this.objects );\n\t\t\tconsole.log( ( this.parent ? space + ' ' : ' ' ), '+ children ( ', this.nodesIndices.length, ' )', this.nodesIndices, this.nodesByIndex );\n\t\t\t\n\t\t\tfor ( i = 0, l = this.nodesIndices.length; i < l; i ++ ) {\n\t\t\t\t\n\t\t\t\tnode = this.nodesByIndex[ this.nodesIndices[ i ] ];\n\t\t\t\t\n\t\t\t\tnode.toConsole( space + spaceAddition );\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t};\n\n\t/*===================================================\n\n\traycaster additional functionality\n\n\t=====================================================*/\n\t\n\tTHREE.Raycaster.prototype.intersectOctreeObject = function ( object, recursive ) {\n\t\t\n\t\tvar intersects,\n\t\t\toctreeObject,\n\t\t\tfacesAll,\n\t\t\tfacesSearch;\n\t\t\n\t\tif ( object.object instanceof THREE.Object3D ) {\n\t\t\t\n\t\t\toctreeObject = object;\n\t\t\tobject = octreeObject.object;\n\t\t\t\n\t\t\t// temporarily replace object geometry's faces with octree object faces\n\t\t\t\n\t\t\tfacesSearch = octreeObject.faces;\n\t\t\tfacesAll = object.geometry.faces;\n\t\t\t\n\t\t\tif ( facesSearch.length > 0 ) {\n\t\t\t\t\n\t\t\t\tobject.geometry.faces = facesSearch;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// intersect\n\t\t\t\n\t\t\tintersects = this.intersectObject( object, recursive );\n\t\t\t\n\t\t\t// revert object geometry's faces\n\t\t\t\n\t\t\tif ( facesSearch.length > 0 ) {\n\t\t\t\t\n\t\t\t\tobject.geometry.faces = facesAll;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tintersects = this.intersectObject( object, recursive );\n\t\t\t\n\t\t}\n\t\t\n\t\treturn intersects;\n\t\t\n\t};\n\t\n\tTHREE.Raycaster.prototype.intersectOctreeObjects = function ( objects, recursive ) {\n\t\t\n\t\tvar i, il,\n\t\t\tintersects = [];\n\t\t\n\t\tfor ( i = 0, il = objects.length; i < il; i ++ ) {\n\t\t\t\n\t\t\tintersects = intersects.concat( this.intersectOctreeObject( objects[ i ], recursive ) );\n\t\t\n\t\t}\n\t\t\n\t\treturn intersects;\n\t\t\n\t};\n\n}( THREE ) );\n"]}