{"version":3,"sources":["threejs/VolumeSlice.js"],"names":["THREE","VolumeSlice","volume","index","axis","slice","this","Object","defineProperty","get","set","value","geometryNeedsUpdate","canvas","document","createElement","canvasBuffer","updateGeometry","canvasMap","Texture","minFilter","LinearFilter","wrapS","wrapT","ClampToEdgeWrapping","material","MeshBasicMaterial","map","side","DoubleSide","transparent","mesh","Mesh","geometry","repaint","prototype","constructor","iLength","jLength","sliceAccess","ctx","ctxBuffer","imgData","getImageData","data","volumeData","upperThreshold","lowerThreshold","windowLow","windowHigh","pixelCount","dataType","j","i","label","colorMap","length","color","alpha","Math","floor","putImageData","drawImage","width","height","needsUpdate","extracted","extractPerpendicularPlane","matrix","planeWidth","planeHeight","getContext","PlaneGeometry","Matrix4","identity","applyMatrix"],"mappings":"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","file":"../../threejs/VolumeSlice.js","sourcesContent":["/**\n * This class has been made to hold a slice of a volume data\n * @class\n * @author Valentin Demeusy / https://github.com/stity\n * @param   {THREE.Volume} volume    The associated volume\n * @param   {number}       [index=0] The index of the slice\n * @param   {string}       [axis='z']      For now only 'x', 'y' or 'z' but later it will change to a normal vector\n * @see THREE.Volume\n */\nTHREE.VolumeSlice = function( volume, index, axis ) {\n\n\tvar slice = this;\n\t/**\n\t * @member {THREE.Volume} volume The associated volume\n\t */\n\tthis.volume = volume;\n\t/**\n\t * @member {Number} index The index of the slice, if changed, will automatically call updateGeometry at the next repaint\n\t */\n\tindex = index || 0;\n\tObject.defineProperty( this, 'index', {\n\t\tget : function() {\n\n\t\t\treturn index;\n\n\t\t},\n\t\tset : function( value ) {\n\n\t\t\tindex = value;\n\t\t\tslice.geometryNeedsUpdate = true;\n\t\t\treturn index;\n\n\t\t}\n\t} );\n\t/**\n\t * @member {String} axis The normal axis\n\t */\n\tthis.axis = axis || 'z';\n\n\t/**\n\t * @member {HTMLCanvasElement} canvas The final canvas used for the texture\n\t */\n\t/**\n\t * @member {CanvasRenderingContext2D} ctx Context of the canvas\n\t */\n\tthis.canvas = document.createElement( 'canvas' );\n\t/**\n\t * @member {HTMLCanvasElement} canvasBuffer The intermediary canvas used to paint the data\n\t */\n\t/**\n\t * @member {CanvasRenderingContext2D} ctxBuffer Context of the canvas buffer\n\t */\n\tthis.canvasBuffer = document.createElement( 'canvas' );\n\tthis.updateGeometry();\n\n\n\tvar canvasMap = new THREE.Texture( this.canvas );\n\tcanvasMap.minFilter = THREE.LinearFilter;\n\tcanvasMap.wrapS = canvasMap.wrapT = THREE.ClampToEdgeWrapping;\n\tvar material = new THREE.MeshBasicMaterial( { map: canvasMap, side: THREE.DoubleSide, transparent : true } );\n\t/**\n\t * @member {THREE.Mesh} mesh The mesh ready to get used in the scene\n\t */\n\tthis.mesh = new THREE.Mesh( this.geometry, material );\n\t/**\n\t * @member {Boolean} geometryNeedsUpdate If set to true, updateGeometry will be triggered at the next repaint\n\t */\n\tthis.geometryNeedsUpdate = true;\n\tthis.repaint();\n\n\t/**\n\t * @member {Number} iLength Width of slice in the original coordinate system, corresponds to the width of the buffer canvas\n\t */\n\n\t/**\n\t * @member {Number} jLength Height of slice in the original coordinate system, corresponds to the height of the buffer canvas\n\t */\n\n\t/**\n\t * @member {Function} sliceAccess Function that allow the slice to access right data\n\t * @see THREE.Volume.extractPerpendicularPlane\n\t * @param {Number} i The first coordinate\n\t * @param {Number} j The second coordinate\n\t * @returns {Number} the index corresponding to the voxel in volume.data of the given position in the slice\n\t */\n\n\n}\n\nTHREE.VolumeSlice.prototype = {\n\n\tconstructor : THREE.VolumeSlice,\n\n\t/**\n\t * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true\n\t * @memberof THREE.VolumeSlice\n\t */\n\trepaint : function() {\n\n\t\tif ( this.geometryNeedsUpdate ) {\n\n\t\t\tthis.updateGeometry();\n\n\t\t}\n\n\t\tvar iLength = this.iLength,\n\t\tjLength = this.jLength,\n\t\tsliceAccess = this.sliceAccess,\n\t\tvolume = this.volume,\n\t\taxis = this.axis,\n\t\tindex = this.index,\n\t\tcanvas = this.canvasBuffer,\n\t\tctx = this.ctxBuffer;\n\n\n\t\t// get the imageData and pixel array from the canvas\n\t\tvar imgData = ctx.getImageData( 0, 0, iLength, jLength );\n\t\tvar data = imgData.data;\n\t\tvar volumeData = volume.data;\n\t\tvar upperThreshold = volume.upperThreshold;\n\t\tvar lowerThreshold = volume.lowerThreshold;\n\t\tvar windowLow = volume.windowLow;\n\t\tvar windowHigh = volume.windowHigh;\n\n\t\t// manipulate some pixel elements\n\t\tvar pixelCount = 0;\n\n\t\tif ( volume.dataType === 'label' ) {\n\n\t\t\t//this part is currently useless but will be used when colortables will be handled\n\t\t\tfor ( var j = 0; j < jLength; j ++ ) {\n\n\t\t\t\tfor ( var i = 0; i < iLength; i ++ ) {\n\n\t\t\t\t\tvar label = volumeData[ sliceAccess( i, j ) ];\n\t\t\t\t\tlabel = label >= this.colorMap.length ? ( label % this.colorMap.length ) + 1 : label;\n\t\t\t\t\tvar color = this.colorMap[ label ];\n\t\t\t\t\tdata[ 4 * pixelCount ] = ( color >> 24 ) & 0xff;\n\t\t\t\t\tdata[ 4 * pixelCount + 1 ] = ( color >> 16 ) & 0xff;\n\t\t\t\t\tdata[ 4 * pixelCount + 2 ] = ( color >> 8 ) & 0xff;\n\t\t\t\t\tdata[ 4 * pixelCount + 3 ] = color & 0xff;\n\t\t\t\t\tpixelCount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t\telse {\n\n\t\t\tfor ( var j = 0; j < jLength; j ++ ) {\n\n\t\t\t\tfor ( var i = 0; i < iLength; i ++ ) {\n\n\t\t\t\t\tvar value = volumeData[ sliceAccess( i, j ) ];\n\t\t\t\t\tvar alpha = 0xff;\n\t\t\t\t\t//apply threshold\n\t\t\t\t\talpha = upperThreshold >= value ? ( lowerThreshold <= value ? alpha : 0 ) : 0;\n\t\t\t\t\t//apply window level\n\t\t\t\t\tvalue = Math.floor( 255 * ( value - windowLow ) / ( windowHigh - windowLow ) );\n\t\t\t\t\tvalue = value > 255 ? 255 : ( value < 0 ? 0 : value | 0 );\n\n\t\t\t\t\tdata[ 4 * pixelCount ] = value;\n\t\t\t\t\tdata[ 4 * pixelCount + 1 ] = value;\n\t\t\t\t\tdata[ 4 * pixelCount + 2 ] = value;\n\t\t\t\t\tdata[ 4 * pixelCount + 3 ] = alpha;\n\t\t\t\t\tpixelCount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t\tctx.putImageData( imgData, 0, 0 );\n\t\tthis.ctx.drawImage( canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height );\n\n\n\t\tthis.mesh.material.map.needsUpdate = true;\n\n\t},\n\n\t/**\n\t * @member {Function} Refresh the geometry according to axis and index\n\t * @see THREE.Volume.extractPerpendicularPlane\n\t * @memberof THREE.VolumeSlice\n\t */\n\tupdateGeometry : function() {\n\n\t\tvar extracted = this.volume.extractPerpendicularPlane( this.axis, this.index );\n\t\tthis.sliceAccess = extracted.sliceAccess;\n\t\tthis.jLength = extracted.jLength;\n\t\tthis.iLength = extracted.iLength;\n\t\tthis.matrix = extracted.matrix;\n\n\t\tthis.canvas.width = extracted.planeWidth;\n\t\tthis.canvas.height = extracted.planeHeight;\n\t\tthis.canvasBuffer.width = this.iLength;\n\t\tthis.canvasBuffer.height = this.jLength;\n\t\tthis.ctx = this.canvas.getContext( '2d' );\n\t\tthis.ctxBuffer = this.canvasBuffer.getContext( '2d' );\n\n\t\tthis.geometry = new THREE.PlaneGeometry( extracted.planeWidth, extracted.planeHeight );\n\n\t\tif ( this.mesh ) {\n\n\t\t\tthis.mesh.geometry = this.geometry;\n\t\t\t//reset mesh matrix\n\t\t\tthis.mesh.matrix = ( new THREE.Matrix4() ).identity();\n\t\t\tthis.mesh.applyMatrix( this.matrix );\n\n\t\t}\n\n\t\tthis.geometryNeedsUpdate = false;\n\n\t}\n\n}\n"]}