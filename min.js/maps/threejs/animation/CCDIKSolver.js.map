{"version":3,"sources":["threejs/animation/CCDIKSolver.js"],"names":["THREE","CCDIKSolver","mesh","this","prototype","constructor","update","effectorVec","Vector3","targetVec","axis","q","Quaternion","bones","skeleton","iks","geometry","math","Math","i","il","length","ik","effector","targetPos","target","getWorldPosition","links","iteration","undefined","j","k","kl","link","index","limitation","linkPos","invLinkQ","getWorldQuaternion","inverse","effectorPos","subVectors","applyQuaternion","normalize","angle","dot","acos","minAngle","maxAngle","crossVectors","setFromAxisAngle","quaternion","multiply","c","w","c2","sqrt","set","x","y","z","updateMatrixWorld"],"mappings":"AAoBAA,MAAMC,YAAc,SAAWC,GAE9BC,KAAKD,KAAOA,GAIbF,MAAMC,YAAYG,WAEjBC,YAAaL,MAAMC,YAEnBK,OAAQ,WAaP,IAAM,IAXFC,EAAc,IAAIP,MAAMQ,QACxBC,EAAY,IAAIT,MAAMQ,QACtBE,EAAO,IAAIV,MAAMQ,QACjBG,EAAI,IAAIX,MAAMY,WAEdC,EAAQV,KAAKD,KAAKY,SAASD,MAC3BE,EAAMZ,KAAKD,KAAKc,SAASD,IAGzBE,EAAOC,KAEDC,EAAI,EAAGC,EAAKL,EAAIM,OAAQF,EAAIC,EAAID,IASzC,IAAM,IAPFG,EAAKP,EAAKI,GACVI,EAAWV,EAAOS,EAAGC,UAErBC,EADSX,EAAOS,EAAGG,QACAC,mBACnBC,EAAQL,EAAGK,MACXC,OAA6BC,IAAjBP,EAAGM,UAA0BN,EAAGM,UAAY,EAElDE,EAAI,EAAGA,EAAIF,EAAWE,IAE/B,IAAM,IAAIC,EAAI,EAAGC,EAAKL,EAAMN,OAAQU,EAAIC,EAAID,IAAM,CAEjD,IAAIE,EAAOpB,EAAOc,EAAOI,GAAIG,OACzBC,EAAaR,EAAOI,GAAII,WACxBC,EAAUH,EAAKP,mBACfW,EAAWJ,EAAKK,qBAAqBC,UACrCC,EAAcjB,EAASG,mBAG3BnB,EAAYkC,WAAYD,EAAaJ,GACrC7B,EAAYmC,gBAAiBL,GAC7B9B,EAAYoC,YAEZlC,EAAUgC,WAAYjB,EAAWY,GACjC3B,EAAUiC,gBAAiBL,GAC3B5B,EAAUkC,YAEV,IAAIC,EAAQnC,EAAUoC,IAAKtC,GAoC3B,GA/BKqC,EAAQ,EAEZA,EAAQ,EAEGA,GAAS,IAEpBA,GAAS,GAIVA,EAAQ3B,EAAK6B,KAAMF,QAEEf,IAAhBP,EAAGyB,UAA0BH,EAAQtB,EAAGyB,WAE5CH,EAAQtB,EAAGyB,eAISlB,IAAhBP,EAAG0B,UAA0BJ,EAAQtB,EAAG0B,WAE5CJ,EAAQtB,EAAG0B,UAIZtC,EAAKuC,aAAc1C,EAAaE,GAChCC,EAAKiC,YAELhC,EAAEuC,iBAAkBxC,EAAMkC,GAC1BX,EAAKkB,WAAWC,SAAUzC,QAGNkB,IAAfM,EAA2B,CAE/B,IAAIkB,EAAIpB,EAAKkB,WAAWG,EAEnBD,EAAI,IAERA,EAAI,GAIL,IAAIE,EAAKtC,EAAKuC,KAAM,EAAIH,EAAIA,GAC5BpB,EAAKkB,WAAWM,IAAKtB,EAAWuB,EAAIH,EACfpB,EAAWwB,EAAIJ,EACfpB,EAAWyB,EAAIL,EACfF,GAItBpB,EAAK4B,mBAAmB","file":"../../../threejs/animation/CCDIKSolver.js","sourcesContent":["/**\n * @author takahiro / https://github.com/takahirox\n *\n * CCD Algorithm\n *  https://sites.google.com/site/auraliusproject/ccd-algorithm\n *\n * mesh.geometry needs to have iks array.\n *\n * ik parameter example\n *\n * ik = {\n *\ttarget: 1,\n *\teffector: 2,\n *\tlinks: [ { index: 5 }, { index: 4, limitation: new THREE.Vector3( 1, 0, 0 ) }, { index : 3 } ],\n *\titeration: 10,\n *\tminAngle: 0.0,\n *\tmaxAngle: 1.0,\n * };\n */\n\nTHREE.CCDIKSolver = function ( mesh ) {\n\n\tthis.mesh = mesh;\n\n};\n\nTHREE.CCDIKSolver.prototype = {\n\n\tconstructor: THREE.CCDIKSolver,\n\n\tupdate: function () {\n\n\t\tvar effectorVec = new THREE.Vector3();\n\t\tvar targetVec = new THREE.Vector3();\n\t\tvar axis = new THREE.Vector3();\n\t\tvar q = new THREE.Quaternion();\n\n\t\tvar bones = this.mesh.skeleton.bones;\n\t\tvar iks = this.mesh.geometry.iks;\n\n\t\t// for reference overhead reduction in loop\n\t\tvar math = Math;\n\n\t\tfor ( var i = 0, il = iks.length; i < il; i++ ) {\n\n\t\t\tvar ik = iks[ i ];\n\t\t\tvar effector = bones[ ik.effector ];\n\t\t\tvar target = bones[ ik.target ];\n\t\t\tvar targetPos = target.getWorldPosition();\n\t\t\tvar links = ik.links;\n\t\t\tvar iteration = ik.iteration !== undefined ? ik.iteration : 1;\n\n\t\t\tfor ( var j = 0; j < iteration; j++ ) {\n\n\t\t\t\tfor ( var k = 0, kl = links.length; k < kl; k++ ) {\n\n\t\t\t\t\tvar link = bones[ links[ k ].index ];\n\t\t\t\t\tvar limitation = links[ k ].limitation;\n\t\t\t\t\tvar linkPos = link.getWorldPosition();\n\t\t\t\t\tvar invLinkQ = link.getWorldQuaternion().inverse();\n\t\t\t\t\tvar effectorPos = effector.getWorldPosition();\n\n\t\t\t\t\t// work in link world\n\t\t\t\t\teffectorVec.subVectors( effectorPos, linkPos );\n\t\t\t\t\teffectorVec.applyQuaternion( invLinkQ );\n\t\t\t\t\teffectorVec.normalize();\n\n\t\t\t\t\ttargetVec.subVectors( targetPos, linkPos );\n\t\t\t\t\ttargetVec.applyQuaternion( invLinkQ );\n\t\t\t\t\ttargetVec.normalize();\n\n\t\t\t\t\tvar angle = targetVec.dot( effectorVec );\n\n\t\t\t\t\t// TODO: continue (or break) the loop for the performance\n\t\t\t\t\t//       if no longer needs to rotate (angle > 1.0-1e-5 ?)\n\n\t\t\t\t\tif ( angle > 1.0 ) {\n\n\t\t\t\t\t\tangle = 1.0;\n\n\t\t\t\t\t} else if ( angle < -1.0 ) {\n\n\t\t\t\t\t\tangle = -1.0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tangle = math.acos( angle );\n\n\t\t\t\t\tif ( ik.minAngle !== undefined && angle < ik.minAngle ) {\n\n\t\t\t\t\t\tangle = ik.minAngle;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ik.maxAngle !== undefined && angle > ik.maxAngle ) {\n\n\t\t\t\t\t\tangle = ik.maxAngle;\n\n\t\t\t\t\t}\n\n\t\t\t\t\taxis.crossVectors( effectorVec, targetVec );\n\t\t\t\t\taxis.normalize();\n\n\t\t\t\t\tq.setFromAxisAngle( axis, angle );\n\t\t\t\t\tlink.quaternion.multiply( q );\n\n\t\t\t\t\t// TODO: re-consider the limitation specification\n\t\t\t\t\tif ( limitation !== undefined ) {\n\n\t\t\t\t\t\tvar c = link.quaternion.w;\n\n\t\t\t\t\t\tif ( c > 1.0 ) {\n\n\t\t\t\t\t\t\tc = 1.0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar c2 = math.sqrt( 1 - c * c );\n\t\t\t\t\t\tlink.quaternion.set( limitation.x * c2,\n\t\t\t\t\t\t                     limitation.y * c2,\n\t\t\t\t\t\t                     limitation.z * c2,\n\t\t\t\t\t\t                     c );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlink.updateMatrixWorld( true );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\n"]}