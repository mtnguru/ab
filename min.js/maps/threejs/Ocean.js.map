{"version":3,"sources":["threejs/Ocean.js"],"names":["THREE","Ocean","renderer","camera","scene","options","optionalParameter","value","defaultValue","undefined","this","changed","initial","oceanCamera","OrthographicCamera","position","z","clearColor","Scene","CLEAR_COLOR","geometryOrigin","GEOMETRY_ORIGIN","sunDirectionX","SUN_DIRECTION","sunDirectionY","sunDirectionZ","oceanColor","OCEAN_COLOR","Vector3","skyColor","SKY_COLOR","exposure","EXPOSURE","geometryResolution","GEOMETRY_RESOLUTION","geometrySize","GEOMETRY_SIZE","resolution","RESOLUTION","floatSize","SIZE_OF_FLOAT","windX","INITIAL_WIND","windY","size","INITIAL_SIZE","choppiness","INITIAL_CHOPPINESS","matrixNeedsUpdate","renderTargetType","USE_HALF_FLOAT","HalfFloatType","FloatType","LinearClampParams","minFilter","LinearFilter","magFilter","wrapS","ClampToEdgeWrapping","wrapT","format","RGBAFormat","stencilBuffer","depthBuffer","premultiplyAlpha","type","NearestClampParams","NearestFilter","NearestRepeatParams","RepeatWrapping","initialSpectrumFramebuffer","WebGLRenderTarget","spectrumFramebuffer","pingPhaseFramebuffer","pongPhaseFramebuffer","pingTransformFramebuffer","pongTransformFramebuffer","displacementMapFramebuffer","normalMapFramebuffer","fullscreeenVertexShader","ShaderLib","oceanHorizontalShader","oceanHorizontalUniforms","UniformsUtils","clone","uniforms","materialOceanHorizontal","ShaderMaterial","vertexShader","fragmentShader","u_transformSize","u_subtransformSize","u_input","depthTest","oceanVerticalShader","oceanVerticalUniforms","materialOceanVertical","initialSpectrumShader","initialSpectrumUniforms","materialInitialSpectrum","u_wind","Vector2","u_resolution","phaseShader","phaseUniforms","materialPhase","spectrumShader","spectrumUniforms","materialSpectrum","u_initialSpectrum","normalShader","normalUniforms","materialNormal","u_displacementMap","oceanShader","oceanUniforms","materialOcean","u_geometrySize","texture","u_normalMap","u_oceanColor","u_skyColor","u_sunDirection","u_exposure","blending","screenQuad","Mesh","PlaneBufferGeometry","add","generateSeedPhaseTexture","generateMesh","prototype","geometry","rotateX","Math","PI","oceanMesh","render","overrideMaterial","renderInitialSpectrum","renderWavePhase","renderSpectrum","renderSpectrumFFT","renderNormalMap","pingPhase","phaseArray","window","Float32Array","i","j","random","pingPhaseTexture","DataTexture","needsUpdate","set","u_size","material","u_phases","u_deltaTime","deltaTime","u_choppiness","iterations","log","pow"],"mappings":"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","file":"../../threejs/Ocean.js","sourcesContent":["THREE.Ocean = function ( renderer, camera, scene, options ) {\n\n\t// flag used to trigger parameter changes\n\tthis.changed = true;\n\tthis.initial = true;\n\n\t// Assign required parameters as object properties\n\tthis.oceanCamera = new THREE.OrthographicCamera(); //camera.clone();\n\tthis.oceanCamera.position.z = 1;\n\tthis.renderer = renderer;\n\tthis.renderer.clearColor( 0xffffff );\n\n\tthis.scene = new THREE.Scene();\n\n\t// Assign optional parameters as variables and object properties\n\tfunction optionalParameter( value, defaultValue ) {\n\n\t\treturn value !== undefined ? value : defaultValue;\n\n\t}\n\toptions = options || {};\n\tthis.clearColor = optionalParameter( options.CLEAR_COLOR, [ 1.0, 1.0, 1.0, 0.0 ] );\n\tthis.geometryOrigin = optionalParameter( options.GEOMETRY_ORIGIN, [ - 1000.0, - 1000.0 ] );\n\tthis.sunDirectionX = optionalParameter( options.SUN_DIRECTION[ 0 ], - 1.0 );\n\tthis.sunDirectionY = optionalParameter( options.SUN_DIRECTION[ 1 ], 1.0 );\n\tthis.sunDirectionZ = optionalParameter( options.SUN_DIRECTION[ 2 ], 1.0 );\n\tthis.oceanColor = optionalParameter( options.OCEAN_COLOR, new THREE.Vector3( 0.004, 0.016, 0.047 ) );\n\tthis.skyColor = optionalParameter( options.SKY_COLOR, new THREE.Vector3( 3.2, 9.6, 12.8 ) );\n\tthis.exposure = optionalParameter( options.EXPOSURE, 0.35 );\n\tthis.geometryResolution = optionalParameter( options.GEOMETRY_RESOLUTION, 32 );\n\tthis.geometrySize = optionalParameter( options.GEOMETRY_SIZE, 2000 );\n\tthis.resolution = optionalParameter( options.RESOLUTION, 64 );\n\tthis.floatSize = optionalParameter( options.SIZE_OF_FLOAT, 4 );\n\tthis.windX = optionalParameter( options.INITIAL_WIND[ 0 ], 10.0 ),\n\tthis.windY = optionalParameter( options.INITIAL_WIND[ 1 ], 10.0 ),\n\tthis.size = optionalParameter( options.INITIAL_SIZE, 250.0 ),\n\tthis.choppiness = optionalParameter( options.INITIAL_CHOPPINESS, 1.5 );\n\n\t//\n\tthis.matrixNeedsUpdate = false;\n\n\t// Setup framebuffer pipeline\n\tvar renderTargetType = optionalParameter( options.USE_HALF_FLOAT, false ) ? THREE.HalfFloatType : THREE.FloatType;\n\tvar LinearClampParams = {\n\t\tminFilter: THREE.LinearFilter,\n\t\tmagFilter: THREE.LinearFilter,\n\t\twrapS: THREE.ClampToEdgeWrapping,\n\t\twrapT: THREE.ClampToEdgeWrapping,\n\t\tformat: THREE.RGBAFormat,\n\t\tstencilBuffer: false,\n\t\tdepthBuffer: false,\n\t\tpremultiplyAlpha: false,\n\t\ttype: renderTargetType\n\t};\n\tvar NearestClampParams = {\n\t\tminFilter: THREE.NearestFilter,\n\t\tmagFilter: THREE.NearestFilter,\n\t\twrapS: THREE.ClampToEdgeWrapping,\n\t\twrapT: THREE.ClampToEdgeWrapping,\n\t\tformat: THREE.RGBAFormat,\n\t\tstencilBuffer: false,\n\t\tdepthBuffer: false,\n\t\tpremultiplyAlpha: false,\n\t\ttype: renderTargetType\n\t};\n\tvar NearestRepeatParams = {\n\t\tminFilter: THREE.NearestFilter,\n\t\tmagFilter: THREE.NearestFilter,\n\t\twrapS: THREE.RepeatWrapping,\n\t\twrapT: THREE.RepeatWrapping,\n\t\tformat: THREE.RGBAFormat,\n\t\tstencilBuffer: false,\n\t\tdepthBuffer: false,\n\t\tpremultiplyAlpha: false,\n\t\ttype: renderTargetType\n\t};\n\tthis.initialSpectrumFramebuffer = new THREE.WebGLRenderTarget( this.resolution, this.resolution, NearestRepeatParams );\n\tthis.spectrumFramebuffer = new THREE.WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );\n\tthis.pingPhaseFramebuffer = new THREE.WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );\n\tthis.pongPhaseFramebuffer = new THREE.WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );\n\tthis.pingTransformFramebuffer = new THREE.WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );\n\tthis.pongTransformFramebuffer = new THREE.WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );\n\tthis.displacementMapFramebuffer = new THREE.WebGLRenderTarget( this.resolution, this.resolution, LinearClampParams );\n\tthis.normalMapFramebuffer = new THREE.WebGLRenderTarget( this.resolution, this.resolution, LinearClampParams );\n\n\t// Define shaders and constant uniforms\n\t////////////////////////////////////////\n\n\t// 0 - The vertex shader used in all of the simulation steps\n\tvar fullscreeenVertexShader = THREE.ShaderLib[ \"ocean_sim_vertex\" ];\n\n\t// 1 - Horizontal wave vertices used for FFT\n\tvar oceanHorizontalShader = THREE.ShaderLib[ \"ocean_subtransform\" ];\n\tvar oceanHorizontalUniforms = THREE.UniformsUtils.clone( oceanHorizontalShader.uniforms );\n\tthis.materialOceanHorizontal = new THREE.ShaderMaterial( {\n\t\tuniforms: oceanHorizontalUniforms,\n\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\tfragmentShader: \"#define HORIZONTAL \\n\" + oceanHorizontalShader.fragmentShader\n\t} );\n\tthis.materialOceanHorizontal.uniforms.u_transformSize = { value: this.resolution };\n\tthis.materialOceanHorizontal.uniforms.u_subtransformSize = { value: null };\n\tthis.materialOceanHorizontal.uniforms.u_input = { value: null };\n\tthis.materialOceanHorizontal.depthTest = false;\n\n\t// 2 - Vertical wave vertices used for FFT\n\tvar oceanVerticalShader = THREE.ShaderLib[ \"ocean_subtransform\" ];\n\tvar oceanVerticalUniforms = THREE.UniformsUtils.clone( oceanVerticalShader.uniforms );\n\tthis.materialOceanVertical = new THREE.ShaderMaterial( {\n\t\tuniforms: oceanVerticalUniforms,\n\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\tfragmentShader: oceanVerticalShader.fragmentShader\n\t} );\n\tthis.materialOceanVertical.uniforms.u_transformSize = { value: this.resolution };\n\tthis.materialOceanVertical.uniforms.u_subtransformSize = { value: null };\n\tthis.materialOceanVertical.uniforms.u_input = { value: null };\n\tthis.materialOceanVertical.depthTest = false;\n\n\t// 3 - Initial spectrum used to generate height map\n\tvar initialSpectrumShader = THREE.ShaderLib[ \"ocean_initial_spectrum\" ];\n\tvar initialSpectrumUniforms = THREE.UniformsUtils.clone( initialSpectrumShader.uniforms );\n\tthis.materialInitialSpectrum = new THREE.ShaderMaterial( {\n\t\tuniforms: initialSpectrumUniforms,\n\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\tfragmentShader: initialSpectrumShader.fragmentShader\n\t} );\n\tthis.materialInitialSpectrum.uniforms.u_wind = { value: new THREE.Vector2() };\n\tthis.materialInitialSpectrum.uniforms.u_resolution = { value: this.resolution };\n\tthis.materialInitialSpectrum.depthTest = false;\n\n\t// 4 - Phases used to animate heightmap\n\tvar phaseShader = THREE.ShaderLib[ \"ocean_phase\" ];\n\tvar phaseUniforms = THREE.UniformsUtils.clone( phaseShader.uniforms );\n\tthis.materialPhase = new THREE.ShaderMaterial( {\n\t\tuniforms: phaseUniforms,\n\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\tfragmentShader: phaseShader.fragmentShader\n\t} );\n\tthis.materialPhase.uniforms.u_resolution = { value: this.resolution };\n\tthis.materialPhase.depthTest = false;\n\n\t// 5 - Shader used to update spectrum\n\tvar spectrumShader = THREE.ShaderLib[ \"ocean_spectrum\" ];\n\tvar spectrumUniforms = THREE.UniformsUtils.clone( spectrumShader.uniforms );\n\tthis.materialSpectrum = new THREE.ShaderMaterial( {\n\t\tuniforms: spectrumUniforms,\n\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\tfragmentShader: spectrumShader.fragmentShader\n\t} );\n\tthis.materialSpectrum.uniforms.u_initialSpectrum = { value: null };\n\tthis.materialSpectrum.uniforms.u_resolution = { value: this.resolution };\n\tthis.materialSpectrum.depthTest = false;\n\n\t// 6 - Shader used to update spectrum normals\n\tvar normalShader = THREE.ShaderLib[ \"ocean_normals\" ];\n\tvar normalUniforms = THREE.UniformsUtils.clone( normalShader.uniforms );\n\tthis.materialNormal = new THREE.ShaderMaterial( {\n\t\tuniforms: normalUniforms,\n\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\tfragmentShader: normalShader.fragmentShader\n\t} );\n\tthis.materialNormal.uniforms.u_displacementMap = { value: null };\n\tthis.materialNormal.uniforms.u_resolution = { value: this.resolution };\n\tthis.materialNormal.depthTest = false;\n\n\t// 7 - Shader used to update normals\n\tvar oceanShader = THREE.ShaderLib[ \"ocean_main\" ];\n\tvar oceanUniforms = THREE.UniformsUtils.clone( oceanShader.uniforms );\n\tthis.materialOcean = new THREE.ShaderMaterial( {\n\t\tuniforms: oceanUniforms,\n\t\tvertexShader: oceanShader.vertexShader,\n\t\tfragmentShader: oceanShader.fragmentShader\n\t} );\n\t// this.materialOcean.wireframe = true;\n\tthis.materialOcean.uniforms.u_geometrySize = { value: this.resolution };\n\tthis.materialOcean.uniforms.u_displacementMap = { value: this.displacementMapFramebuffer.texture };\n\tthis.materialOcean.uniforms.u_normalMap = { value: this.normalMapFramebuffer.texture };\n\tthis.materialOcean.uniforms.u_oceanColor = { value: this.oceanColor };\n\tthis.materialOcean.uniforms.u_skyColor = { value: this.skyColor };\n\tthis.materialOcean.uniforms.u_sunDirection = { value: new THREE.Vector3( this.sunDirectionX, this.sunDirectionY, this.sunDirectionZ ) };\n\tthis.materialOcean.uniforms.u_exposure = { value: this.exposure };\n\n\t// Disable blending to prevent default premultiplied alpha values\n\tthis.materialOceanHorizontal.blending = 0;\n\tthis.materialOceanVertical.blending = 0;\n\tthis.materialInitialSpectrum.blending = 0;\n\tthis.materialPhase.blending = 0;\n\tthis.materialSpectrum.blending = 0;\n\tthis.materialNormal.blending = 0;\n\tthis.materialOcean.blending = 0;\n\n\t// Create the simulation plane\n\tthis.screenQuad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ) );\n\tthis.scene.add( this.screenQuad );\n\n\t// Initialise spectrum data\n\tthis.generateSeedPhaseTexture();\n\n\t// Generate the ocean mesh\n\tthis.generateMesh();\n\n};\n\nTHREE.Ocean.prototype.generateMesh = function () {\n\n\tvar geometry = new THREE.PlaneBufferGeometry( this.geometrySize, this.geometrySize, this.geometryResolution, this.geometryResolution );\n\n\tgeometry.rotateX( - Math.PI / 2 );\n\n\tthis.oceanMesh = new THREE.Mesh( geometry, this.materialOcean );\n\n};\n\nTHREE.Ocean.prototype.render = function () {\n\n\tthis.scene.overrideMaterial = null;\n\n\tif ( this.changed )\n\t\tthis.renderInitialSpectrum();\n\n\tthis.renderWavePhase();\n\tthis.renderSpectrum();\n\tthis.renderSpectrumFFT();\n\tthis.renderNormalMap();\n\tthis.scene.overrideMaterial = null;\n\n};\n\nTHREE.Ocean.prototype.generateSeedPhaseTexture = function() {\n\n\t// Setup the seed texture\n\tthis.pingPhase = true;\n\tvar phaseArray = new window.Float32Array( this.resolution * this.resolution * 4 );\n\tfor ( var i = 0; i < this.resolution; i ++ ) {\n\n\t\tfor ( var j = 0; j < this.resolution; j ++ ) {\n\n\t\t\tphaseArray[ i * this.resolution * 4 + j * 4 ] =  Math.random() * 2.0 * Math.PI;\n\t\t\tphaseArray[ i * this.resolution * 4 + j * 4 + 1 ] = 0.0;\n\t\t\tphaseArray[ i * this.resolution * 4 + j * 4 + 2 ] = 0.0;\n\t\t\tphaseArray[ i * this.resolution * 4 + j * 4 + 3 ] = 0.0;\n\n\t\t}\n\n\t}\n\n\tthis.pingPhaseTexture = new THREE.DataTexture( phaseArray, this.resolution, this.resolution, THREE.RGBAFormat );\n\tthis.pingPhaseTexture.wrapS = THREE.ClampToEdgeWrapping;\n\tthis.pingPhaseTexture.wrapT = THREE.ClampToEdgeWrapping;\n\tthis.pingPhaseTexture.type = THREE.FloatType;\n\tthis.pingPhaseTexture.needsUpdate = true;\n\n};\n\nTHREE.Ocean.prototype.renderInitialSpectrum = function () {\n\n\tthis.scene.overrideMaterial = this.materialInitialSpectrum;\n\tthis.materialInitialSpectrum.uniforms.u_wind.value.set( this.windX, this.windY );\n\tthis.materialInitialSpectrum.uniforms.u_size.value = this.size;\n\tthis.renderer.render( this.scene, this.oceanCamera, this.initialSpectrumFramebuffer, true );\n\n};\n\nTHREE.Ocean.prototype.renderWavePhase = function () {\n\n\tthis.scene.overrideMaterial = this.materialPhase;\n\tthis.screenQuad.material = this.materialPhase;\n\tif ( this.initial ) {\n\n\t\tthis.materialPhase.uniforms.u_phases.value = this.pingPhaseTexture;\n\t\tthis.initial = false;\n\n\t}else {\n\n\t\tthis.materialPhase.uniforms.u_phases.value = this.pingPhase ? this.pingPhaseFramebuffer.texture : this.pongPhaseFramebuffer.texture;\n\n\t}\n\tthis.materialPhase.uniforms.u_deltaTime.value = this.deltaTime;\n\tthis.materialPhase.uniforms.u_size.value = this.size;\n\tthis.renderer.render( this.scene, this.oceanCamera, this.pingPhase ? this.pongPhaseFramebuffer : this.pingPhaseFramebuffer );\n\tthis.pingPhase = ! this.pingPhase;\n\n};\n\nTHREE.Ocean.prototype.renderSpectrum = function () {\n\n\tthis.scene.overrideMaterial = this.materialSpectrum;\n\tthis.materialSpectrum.uniforms.u_initialSpectrum.value = this.initialSpectrumFramebuffer.texture;\n\tthis.materialSpectrum.uniforms.u_phases.value = this.pingPhase ? this.pingPhaseFramebuffer.texture : this.pongPhaseFramebuffer.texture;\n\tthis.materialSpectrum.uniforms.u_choppiness.value = this.choppiness;\n\tthis.materialSpectrum.uniforms.u_size.value = this.size;\n\tthis.renderer.render( this.scene, this.oceanCamera, this.spectrumFramebuffer );\n\n};\n\nTHREE.Ocean.prototype.renderSpectrumFFT = function() {\n\n\t// GPU FFT using Stockham formulation\n\tvar iterations = Math.log( this.resolution ) / Math.log( 2 ); // log2\n\n\tthis.scene.overrideMaterial = this.materialOceanHorizontal;\n\n\tfor ( var i = 0; i < iterations; i ++ ) {\n\n\t\tif ( i === 0 ) {\n\n\t\t\tthis.materialOceanHorizontal.uniforms.u_input.value = this.spectrumFramebuffer.texture;\n\t\t\tthis.materialOceanHorizontal.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );\n\t\t\tthis.renderer.render( this.scene, this.oceanCamera, this.pingTransformFramebuffer );\n\n\t\t} else if ( i % 2 === 1 ) {\n\n\t\t\tthis.materialOceanHorizontal.uniforms.u_input.value = this.pingTransformFramebuffer.texture;\n\t\t\tthis.materialOceanHorizontal.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );\n\t\t\tthis.renderer.render( this.scene, this.oceanCamera, this.pongTransformFramebuffer );\n\n\t\t} else {\n\n\t\t\tthis.materialOceanHorizontal.uniforms.u_input.value = this.pongTransformFramebuffer.texture;\n\t\t\tthis.materialOceanHorizontal.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );\n\t\t\tthis.renderer.render( this.scene, this.oceanCamera, this.pingTransformFramebuffer );\n\n\t\t}\n\n\t}\n\tthis.scene.overrideMaterial = this.materialOceanVertical;\n\tfor ( var i = iterations; i < iterations * 2; i ++ ) {\n\n\t\tif ( i === iterations * 2 - 1 ) {\n\n\t\t\tthis.materialOceanVertical.uniforms.u_input.value = ( iterations % 2 === 0 ) ? this.pingTransformFramebuffer.texture : this.pongTransformFramebuffer.texture;\n\t\t\tthis.materialOceanVertical.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );\n\t\t\tthis.renderer.render( this.scene, this.oceanCamera, this.displacementMapFramebuffer );\n\n\t\t} else if ( i % 2 === 1 ) {\n\n\t\t\tthis.materialOceanVertical.uniforms.u_input.value = this.pingTransformFramebuffer.texture;\n\t\t\tthis.materialOceanVertical.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );\n\t\t\tthis.renderer.render( this.scene, this.oceanCamera, this.pongTransformFramebuffer );\n\n\t\t} else {\n\n\t\t\tthis.materialOceanVertical.uniforms.u_input.value = this.pongTransformFramebuffer.texture;\n\t\t\tthis.materialOceanVertical.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );\n\t\t\tthis.renderer.render( this.scene, this.oceanCamera, this.pingTransformFramebuffer );\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.Ocean.prototype.renderNormalMap = function () {\n\n\tthis.scene.overrideMaterial = this.materialNormal;\n\tif ( this.changed ) this.materialNormal.uniforms.u_size.value = this.size;\n\tthis.materialNormal.uniforms.u_displacementMap.value = this.displacementMapFramebuffer.texture;\n\tthis.renderer.render( this.scene, this.oceanCamera, this.normalMapFramebuffer, true );\n\n};\n"]}